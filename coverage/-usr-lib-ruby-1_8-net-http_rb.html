<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'><head><title>/usr/lib/ruby/1.8/net/http.rb - C0 code coverage information</title>
    <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
    <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
    <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
    <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
    </head>
  <body><h3>C0 code coverage information</h3>
    <p>Generated on Thu Feb 26 19:12:36 +0300 2009 with <a href='http://eigenclass.org/hiki/rcov'>rcov 0.8.1.2</a>
      </p>
    <hr/>
    <pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
<table class='report'><thead><tr><td class='heading'>Name</td>
      <td class='heading'>Total lines</td>
      <td class='heading'>Lines of code</td>
      <td class='heading'>Total coverage</td>
      <td class='heading'>Code coverage</td>
      </tr>
    </thead>
  <tbody><tr class='light'><td><a href='-usr-lib-ruby-1_8-net-http_rb.html'>/usr/lib/ruby/1.8/net/http.rb</a>
        </td>
      <td class='lines_total'><tt>2277</tt>
        </td>
      <td class='lines_code'><tt>1185</tt>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_total'>84.4%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='84'/>
                  <td class='uncovered' width='16'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_code'>70.2%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='70'/>
                  <td class='uncovered' width='30'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </tbody>
  </table>
<pre><span class="inferred0"><a name="line1"></a>   1 #
</span><span class="inferred1"><a name="line2"></a>   2 # = net/http.rb
</span><span class="inferred0"><a name="line3"></a>   3 #
</span><span class="inferred1"><a name="line4"></a>   4 # Copyright (c) 1999-2006 Yukihiro Matsumoto
</span><span class="inferred0"><a name="line5"></a>   5 # Copyright (c) 1999-2006 Minero Aoki
</span><span class="inferred1"><a name="line6"></a>   6 # Copyright (c) 2001 GOTOU Yuuzou
</span><span class="inferred0"><a name="line7"></a>   7 # 
</span><span class="inferred1"><a name="line8"></a>   8 # Written and maintained by Minero Aoki &lt;aamine@loveruby.net&gt;.
</span><span class="inferred0"><a name="line9"></a>   9 # HTTPS support added by GOTOU Yuuzou &lt;gotoyuzo@notwork.org&gt;.
</span><span class="inferred1"><a name="line10"></a>  10 #
</span><span class="inferred0"><a name="line11"></a>  11 # This file is derived from &quot;http-access.rb&quot;.
</span><span class="inferred1"><a name="line12"></a>  12 #
</span><span class="inferred0"><a name="line13"></a>  13 # Documented by Minero Aoki; converted to RDoc by William Webber.
</span><span class="inferred1"><a name="line14"></a>  14 # 
</span><span class="inferred0"><a name="line15"></a>  15 # This program is free software. You can re-distribute and/or
</span><span class="inferred1"><a name="line16"></a>  16 # modify this program under the same terms of ruby itself ---
</span><span class="inferred0"><a name="line17"></a>  17 # Ruby Distribution License or GNU General Public License.
</span><span class="inferred1"><a name="line18"></a>  18 #
</span><span class="inferred0"><a name="line19"></a>  19 # See Net::HTTP for an overview and examples. 
</span><span class="inferred1"><a name="line20"></a>  20 # 
</span><span class="inferred0"><a name="line21"></a>  21 # NOTE: You can find Japanese version of this document here:
</span><span class="inferred1"><a name="line22"></a>  22 # http://www.ruby-lang.org/ja/man/?cmd=view;name=net%2Fhttp.rb
</span><span class="inferred0"><a name="line23"></a>  23 # 
</span><span class="inferred1"><a name="line24"></a>  24 #--
</span><span class="inferred0"><a name="line25"></a>  25 # $Id: http.rb 13504 2007-09-24 08:12:24Z shyouhei $
</span><span class="inferred1"><a name="line26"></a>  26 #++ 
</span><span class="inferred0"><a name="line27"></a>  27 
</span><span class="marked1"><a name="line28"></a>  28 require 'net/protocol'
</span><span class="marked0"><a name="line29"></a>  29 require 'uri'
</span><span class="inferred1"><a name="line30"></a>  30 
</span><span class="marked0"><a name="line31"></a>  31 module Net   #:nodoc:
</span><span class="inferred1"><a name="line32"></a>  32 
</span><span class="inferred0"><a name="line33"></a>  33   # :stopdoc:
</span><span class="marked1"><a name="line34"></a>  34   class HTTPBadResponse &lt; StandardError; end
</span><span class="marked0"><a name="line35"></a>  35   class HTTPHeaderSyntaxError &lt; StandardError; end
</span><span class="inferred1"><a name="line36"></a>  36   # :startdoc:
</span><span class="inferred0"><a name="line37"></a>  37 
</span><span class="inferred1"><a name="line38"></a>  38   # == What Is This Library?
</span><span class="inferred0"><a name="line39"></a>  39   # 
</span><span class="inferred1"><a name="line40"></a>  40   # This library provides your program functions to access WWW
</span><span class="inferred0"><a name="line41"></a>  41   # documents via HTTP, Hyper Text Transfer Protocol version 1.1.
</span><span class="inferred1"><a name="line42"></a>  42   # For details of HTTP, refer [RFC2616]
</span><span class="inferred0"><a name="line43"></a>  43   # (http://www.ietf.org/rfc/rfc2616.txt).
</span><span class="inferred1"><a name="line44"></a>  44   # 
</span><span class="inferred0"><a name="line45"></a>  45   # == Examples
</span><span class="inferred1"><a name="line46"></a>  46   # 
</span><span class="inferred0"><a name="line47"></a>  47   # === Getting Document From WWW Server
</span><span class="inferred1"><a name="line48"></a>  48   # 
</span><span class="inferred0"><a name="line49"></a>  49   # Example #1: Simple GET+print
</span><span class="inferred1"><a name="line50"></a>  50   # 
</span><span class="inferred0"><a name="line51"></a>  51   #     require 'net/http'
</span><span class="inferred1"><a name="line52"></a>  52   #     Net::HTTP.get_print 'www.example.com', '/index.html'
</span><span class="inferred0"><a name="line53"></a>  53   # 
</span><span class="inferred1"><a name="line54"></a>  54   # Example #2: Simple GET+print by URL
</span><span class="inferred0"><a name="line55"></a>  55   # 
</span><span class="inferred1"><a name="line56"></a>  56   #     require 'net/http'
</span><span class="inferred0"><a name="line57"></a>  57   #     require 'uri'
</span><span class="inferred1"><a name="line58"></a>  58   #     Net::HTTP.get_print URI.parse('http://www.example.com/index.html')
</span><span class="inferred0"><a name="line59"></a>  59   # 
</span><span class="inferred1"><a name="line60"></a>  60   # Example #3: More generic GET+print
</span><span class="inferred0"><a name="line61"></a>  61   # 
</span><span class="inferred1"><a name="line62"></a>  62   #     require 'net/http'
</span><span class="inferred0"><a name="line63"></a>  63   #     require 'uri'
</span><span class="inferred1"><a name="line64"></a>  64   #
</span><span class="inferred0"><a name="line65"></a>  65   #     url = URI.parse('http://www.example.com/index.html')
</span><span class="inferred1"><a name="line66"></a>  66   #     res = Net::HTTP.start(url.host, url.port) {|http|
</span><span class="inferred0"><a name="line67"></a>  67   #       http.get('/index.html')
</span><span class="inferred1"><a name="line68"></a>  68   #     }
</span><span class="inferred0"><a name="line69"></a>  69   #     puts res.body
</span><span class="inferred1"><a name="line70"></a>  70   #
</span><span class="inferred0"><a name="line71"></a>  71   # Example #4: More generic GET+print
</span><span class="inferred1"><a name="line72"></a>  72   # 
</span><span class="inferred0"><a name="line73"></a>  73   #     require 'net/http'
</span><span class="inferred1"><a name="line74"></a>  74   #
</span><span class="inferred0"><a name="line75"></a>  75   #     url = URI.parse('http://www.example.com/index.html')
</span><span class="inferred1"><a name="line76"></a>  76   #     req = Net::HTTP::Get.new(url.path)
</span><span class="inferred0"><a name="line77"></a>  77   #     res = Net::HTTP.start(url.host, url.port) {|http|
</span><span class="inferred1"><a name="line78"></a>  78   #       http.request(req)
</span><span class="inferred0"><a name="line79"></a>  79   #     }
</span><span class="inferred1"><a name="line80"></a>  80   #     puts res.body
</span><span class="inferred0"><a name="line81"></a>  81   # 
</span><span class="inferred1"><a name="line82"></a>  82   # === Posting Form Data
</span><span class="inferred0"><a name="line83"></a>  83   # 
</span><span class="inferred1"><a name="line84"></a>  84   #     require 'net/http'
</span><span class="inferred0"><a name="line85"></a>  85   #     require 'uri'
</span><span class="inferred1"><a name="line86"></a>  86   #
</span><span class="inferred0"><a name="line87"></a>  87   #     #1: Simple POST
</span><span class="inferred1"><a name="line88"></a>  88   #     res = Net::HTTP.post_form(URI.parse('http://www.example.com/search.cgi'),
</span><span class="inferred0"><a name="line89"></a>  89   #                               {'q'=&gt;'ruby', 'max'=&gt;'50'})
</span><span class="inferred1"><a name="line90"></a>  90   #     puts res.body
</span><span class="inferred0"><a name="line91"></a>  91   #
</span><span class="inferred1"><a name="line92"></a>  92   #     #2: POST with basic authentication
</span><span class="inferred0"><a name="line93"></a>  93   #     res = Net::HTTP.post_form(URI.parse('http://jack:pass@www.example.com/todo.cgi'),
</span><span class="inferred1"><a name="line94"></a>  94   #                                         {'from'=&gt;'2005-01-01', 'to'=&gt;'2005-03-31'})
</span><span class="inferred0"><a name="line95"></a>  95   #     puts res.body
</span><span class="inferred1"><a name="line96"></a>  96   #
</span><span class="inferred0"><a name="line97"></a>  97   #     #3: Detailed control
</span><span class="inferred1"><a name="line98"></a>  98   #     url = URI.parse('http://www.example.com/todo.cgi')
</span><span class="inferred0"><a name="line99"></a>  99   #     req = Net::HTTP::Post.new(url.path)
</span><span class="inferred1"><a name="line100"></a> 100   #     req.basic_auth 'jack', 'pass'
</span><span class="inferred0"><a name="line101"></a> 101   #     req.set_form_data({'from'=&gt;'2005-01-01', 'to'=&gt;'2005-03-31'}, ';')
</span><span class="inferred1"><a name="line102"></a> 102   #     res = Net::HTTP.new(url.host, url.port).start {|http| http.request(req) }
</span><span class="inferred0"><a name="line103"></a> 103   #     case res
</span><span class="inferred1"><a name="line104"></a> 104   #     when Net::HTTPSuccess, Net::HTTPRedirection
</span><span class="inferred0"><a name="line105"></a> 105   #       # OK
</span><span class="inferred1"><a name="line106"></a> 106   #     else
</span><span class="inferred0"><a name="line107"></a> 107   #       res.error!
</span><span class="inferred1"><a name="line108"></a> 108   #     end
</span><span class="inferred0"><a name="line109"></a> 109   # 
</span><span class="inferred1"><a name="line110"></a> 110   # === Accessing via Proxy
</span><span class="inferred0"><a name="line111"></a> 111   # 
</span><span class="inferred1"><a name="line112"></a> 112   # Net::HTTP.Proxy creates http proxy class. It has same
</span><span class="inferred0"><a name="line113"></a> 113   # methods of Net::HTTP but its instances always connect to
</span><span class="inferred1"><a name="line114"></a> 114   # proxy, instead of given host.
</span><span class="inferred0"><a name="line115"></a> 115   # 
</span><span class="inferred1"><a name="line116"></a> 116   #     require 'net/http'
</span><span class="inferred0"><a name="line117"></a> 117   # 
</span><span class="inferred1"><a name="line118"></a> 118   #     proxy_addr = 'your.proxy.host'
</span><span class="inferred0"><a name="line119"></a> 119   #     proxy_port = 8080
</span><span class="inferred1"><a name="line120"></a> 120   #             :
</span><span class="inferred0"><a name="line121"></a> 121   #     Net::HTTP::Proxy(proxy_addr, proxy_port).start('www.example.com') {|http|
</span><span class="inferred1"><a name="line122"></a> 122   #       # always connect to your.proxy.addr:8080
</span><span class="inferred0"><a name="line123"></a> 123   #             :
</span><span class="inferred1"><a name="line124"></a> 124   #     }
</span><span class="inferred0"><a name="line125"></a> 125   # 
</span><span class="inferred1"><a name="line126"></a> 126   # Since Net::HTTP.Proxy returns Net::HTTP itself when proxy_addr is nil,
</span><span class="inferred0"><a name="line127"></a> 127   # there's no need to change code if there's proxy or not.
</span><span class="inferred1"><a name="line128"></a> 128   # 
</span><span class="inferred0"><a name="line129"></a> 129   # There are two additional parameters in Net::HTTP.Proxy which allow to
</span><span class="inferred1"><a name="line130"></a> 130   # specify proxy user name and password:
</span><span class="inferred0"><a name="line131"></a> 131   # 
</span><span class="inferred1"><a name="line132"></a> 132   #     Net::HTTP::Proxy(proxy_addr, proxy_port, proxy_user = nil, proxy_pass = nil)
</span><span class="inferred0"><a name="line133"></a> 133   # 
</span><span class="inferred1"><a name="line134"></a> 134   # You may use them to work with authorization-enabled proxies:
</span><span class="inferred0"><a name="line135"></a> 135   # 
</span><span class="inferred1"><a name="line136"></a> 136   #     require 'net/http'
</span><span class="inferred0"><a name="line137"></a> 137   #     require 'uri'
</span><span class="inferred1"><a name="line138"></a> 138   #     
</span><span class="inferred0"><a name="line139"></a> 139   #     proxy_host = 'your.proxy.host'
</span><span class="inferred1"><a name="line140"></a> 140   #     proxy_port = 8080
</span><span class="inferred0"><a name="line141"></a> 141   #     uri = URI.parse(ENV['http_proxy'])
</span><span class="inferred1"><a name="line142"></a> 142   #     proxy_user, proxy_pass = uri.userinfo.split(/:/) if uri.userinfo
</span><span class="inferred0"><a name="line143"></a> 143   #     Net::HTTP::Proxy(proxy_host, proxy_port,
</span><span class="inferred1"><a name="line144"></a> 144   #                      proxy_user, proxy_pass).start('www.example.com') {|http|
</span><span class="inferred0"><a name="line145"></a> 145   #       # always connect to your.proxy.addr:8080 using specified username and password
</span><span class="inferred1"><a name="line146"></a> 146   #             :
</span><span class="inferred0"><a name="line147"></a> 147   #     }
</span><span class="inferred1"><a name="line148"></a> 148   #
</span><span class="inferred0"><a name="line149"></a> 149   # Note that net/http never rely on HTTP_PROXY environment variable.
</span><span class="inferred1"><a name="line150"></a> 150   # If you want to use proxy, set it explicitly.
</span><span class="inferred0"><a name="line151"></a> 151   # 
</span><span class="inferred1"><a name="line152"></a> 152   # === Following Redirection
</span><span class="inferred0"><a name="line153"></a> 153   # 
</span><span class="inferred1"><a name="line154"></a> 154   #     require 'net/http'
</span><span class="inferred0"><a name="line155"></a> 155   #     require 'uri'
</span><span class="inferred1"><a name="line156"></a> 156   # 
</span><span class="inferred0"><a name="line157"></a> 157   #     def fetch(uri_str, limit = 10)
</span><span class="inferred1"><a name="line158"></a> 158   #       # You should choose better exception. 
</span><span class="inferred0"><a name="line159"></a> 159   #       raise ArgumentError, 'HTTP redirect too deep' if limit == 0
</span><span class="inferred1"><a name="line160"></a> 160   # 
</span><span class="inferred0"><a name="line161"></a> 161   #       response = Net::HTTP.get_response(URI.parse(uri_str))
</span><span class="inferred1"><a name="line162"></a> 162   #       case response
</span><span class="inferred0"><a name="line163"></a> 163   #       when Net::HTTPSuccess     then response
</span><span class="inferred1"><a name="line164"></a> 164   #       when Net::HTTPRedirection then fetch(response['location'], limit - 1)
</span><span class="inferred0"><a name="line165"></a> 165   #       else
</span><span class="inferred1"><a name="line166"></a> 166   #         response.error!
</span><span class="inferred0"><a name="line167"></a> 167   #       end
</span><span class="inferred1"><a name="line168"></a> 168   #     end
</span><span class="inferred0"><a name="line169"></a> 169   # 
</span><span class="inferred1"><a name="line170"></a> 170   #     print fetch('http://www.ruby-lang.org')
</span><span class="inferred0"><a name="line171"></a> 171   # 
</span><span class="inferred1"><a name="line172"></a> 172   # Net::HTTPSuccess and Net::HTTPRedirection is a HTTPResponse class.
</span><span class="inferred0"><a name="line173"></a> 173   # All HTTPResponse objects belong to its own response class which
</span><span class="inferred1"><a name="line174"></a> 174   # indicate HTTP result status. For details of response classes,
</span><span class="inferred0"><a name="line175"></a> 175   # see section &quot;HTTP Response Classes&quot;.
</span><span class="inferred1"><a name="line176"></a> 176   # 
</span><span class="inferred0"><a name="line177"></a> 177   # === Basic Authentication
</span><span class="inferred1"><a name="line178"></a> 178   # 
</span><span class="inferred0"><a name="line179"></a> 179   #     require 'net/http'
</span><span class="inferred1"><a name="line180"></a> 180   # 
</span><span class="inferred0"><a name="line181"></a> 181   #     Net::HTTP.start('www.example.com') {|http|
</span><span class="inferred1"><a name="line182"></a> 182   #       req = Net::HTTP::Get.new('/secret-page.html')
</span><span class="inferred0"><a name="line183"></a> 183   #       req.basic_auth 'account', 'password'
</span><span class="inferred1"><a name="line184"></a> 184   #       response = http.request(req)
</span><span class="inferred0"><a name="line185"></a> 185   #       print response.body
</span><span class="inferred1"><a name="line186"></a> 186   #     }
</span><span class="inferred0"><a name="line187"></a> 187   # 
</span><span class="inferred1"><a name="line188"></a> 188   # === HTTP Request Classes
</span><span class="inferred0"><a name="line189"></a> 189   #
</span><span class="inferred1"><a name="line190"></a> 190   # Here is HTTP request class hierarchy.
</span><span class="inferred0"><a name="line191"></a> 191   #
</span><span class="inferred1"><a name="line192"></a> 192   #   Net::HTTPRequest
</span><span class="inferred0"><a name="line193"></a> 193   #       Net::HTTP::Get
</span><span class="inferred1"><a name="line194"></a> 194   #       Net::HTTP::Head
</span><span class="inferred0"><a name="line195"></a> 195   #       Net::HTTP::Post
</span><span class="inferred1"><a name="line196"></a> 196   #       Net::HTTP::Put
</span><span class="inferred0"><a name="line197"></a> 197   #       Net::HTTP::Proppatch
</span><span class="inferred1"><a name="line198"></a> 198   #       Net::HTTP::Lock
</span><span class="inferred0"><a name="line199"></a> 199   #       Net::HTTP::Unlock
</span><span class="inferred1"><a name="line200"></a> 200   #       Net::HTTP::Options
</span><span class="inferred0"><a name="line201"></a> 201   #       Net::HTTP::Propfind
</span><span class="inferred1"><a name="line202"></a> 202   #       Net::HTTP::Delete
</span><span class="inferred0"><a name="line203"></a> 203   #       Net::HTTP::Move
</span><span class="inferred1"><a name="line204"></a> 204   #       Net::HTTP::Copy
</span><span class="inferred0"><a name="line205"></a> 205   #       Net::HTTP::Mkcol
</span><span class="inferred1"><a name="line206"></a> 206   #       Net::HTTP::Trace
</span><span class="inferred0"><a name="line207"></a> 207   #
</span><span class="inferred1"><a name="line208"></a> 208   # === HTTP Response Classes
</span><span class="inferred0"><a name="line209"></a> 209   #
</span><span class="inferred1"><a name="line210"></a> 210   # Here is HTTP response class hierarchy.
</span><span class="inferred0"><a name="line211"></a> 211   # All classes are defined in Net module.
</span><span class="inferred1"><a name="line212"></a> 212   #
</span><span class="inferred0"><a name="line213"></a> 213   #   HTTPResponse
</span><span class="inferred1"><a name="line214"></a> 214   #       HTTPUnknownResponse
</span><span class="inferred0"><a name="line215"></a> 215   #       HTTPInformation                    # 1xx
</span><span class="inferred1"><a name="line216"></a> 216   #           HTTPContinue                       # 100
</span><span class="inferred0"><a name="line217"></a> 217   #           HTTPSwitchProtocl                  # 101
</span><span class="inferred1"><a name="line218"></a> 218   #       HTTPSuccess                        # 2xx
</span><span class="inferred0"><a name="line219"></a> 219   #           HTTPOK                             # 200
</span><span class="inferred1"><a name="line220"></a> 220   #           HTTPCreated                        # 201
</span><span class="inferred0"><a name="line221"></a> 221   #           HTTPAccepted                       # 202
</span><span class="inferred1"><a name="line222"></a> 222   #           HTTPNonAuthoritativeInformation    # 203
</span><span class="inferred0"><a name="line223"></a> 223   #           HTTPNoContent                      # 204
</span><span class="inferred1"><a name="line224"></a> 224   #           HTTPResetContent                   # 205
</span><span class="inferred0"><a name="line225"></a> 225   #           HTTPPartialContent                 # 206
</span><span class="inferred1"><a name="line226"></a> 226   #       HTTPRedirection                    # 3xx
</span><span class="inferred0"><a name="line227"></a> 227   #           HTTPMultipleChoice                 # 300
</span><span class="inferred1"><a name="line228"></a> 228   #           HTTPMovedPermanently               # 301
</span><span class="inferred0"><a name="line229"></a> 229   #           HTTPFound                          # 302
</span><span class="inferred1"><a name="line230"></a> 230   #           HTTPSeeOther                       # 303
</span><span class="inferred0"><a name="line231"></a> 231   #           HTTPNotModified                    # 304
</span><span class="inferred1"><a name="line232"></a> 232   #           HTTPUseProxy                       # 305
</span><span class="inferred0"><a name="line233"></a> 233   #           HTTPTemporaryRedirect              # 307
</span><span class="inferred1"><a name="line234"></a> 234   #       HTTPClientError                    # 4xx
</span><span class="inferred0"><a name="line235"></a> 235   #           HTTPBadRequest                     # 400
</span><span class="inferred1"><a name="line236"></a> 236   #           HTTPUnauthorized                   # 401
</span><span class="inferred0"><a name="line237"></a> 237   #           HTTPPaymentRequired                # 402
</span><span class="inferred1"><a name="line238"></a> 238   #           HTTPForbidden                      # 403
</span><span class="inferred0"><a name="line239"></a> 239   #           HTTPNotFound                       # 404
</span><span class="inferred1"><a name="line240"></a> 240   #           HTTPMethodNotAllowed               # 405
</span><span class="inferred0"><a name="line241"></a> 241   #           HTTPNotAcceptable                  # 406
</span><span class="inferred1"><a name="line242"></a> 242   #           HTTPProxyAuthenticationRequired    # 407
</span><span class="inferred0"><a name="line243"></a> 243   #           HTTPRequestTimeOut                 # 408
</span><span class="inferred1"><a name="line244"></a> 244   #           HTTPConflict                       # 409
</span><span class="inferred0"><a name="line245"></a> 245   #           HTTPGone                           # 410
</span><span class="inferred1"><a name="line246"></a> 246   #           HTTPLengthRequired                 # 411
</span><span class="inferred0"><a name="line247"></a> 247   #           HTTPPreconditionFailed             # 412
</span><span class="inferred1"><a name="line248"></a> 248   #           HTTPRequestEntityTooLarge          # 413
</span><span class="inferred0"><a name="line249"></a> 249   #           HTTPRequestURITooLong              # 414
</span><span class="inferred1"><a name="line250"></a> 250   #           HTTPUnsupportedMediaType           # 415
</span><span class="inferred0"><a name="line251"></a> 251   #           HTTPRequestedRangeNotSatisfiable   # 416
</span><span class="inferred1"><a name="line252"></a> 252   #           HTTPExpectationFailed              # 417
</span><span class="inferred0"><a name="line253"></a> 253   #       HTTPServerError                    # 5xx
</span><span class="inferred1"><a name="line254"></a> 254   #           HTTPInternalServerError            # 500
</span><span class="inferred0"><a name="line255"></a> 255   #           HTTPNotImplemented                 # 501
</span><span class="inferred1"><a name="line256"></a> 256   #           HTTPBadGateway                     # 502
</span><span class="inferred0"><a name="line257"></a> 257   #           HTTPServiceUnavailable             # 503
</span><span class="inferred1"><a name="line258"></a> 258   #           HTTPGatewayTimeOut                 # 504
</span><span class="inferred0"><a name="line259"></a> 259   #           HTTPVersionNotSupported            # 505
</span><span class="inferred1"><a name="line260"></a> 260   # 
</span><span class="inferred0"><a name="line261"></a> 261   # == Switching Net::HTTP versions
</span><span class="inferred1"><a name="line262"></a> 262   # 
</span><span class="inferred0"><a name="line263"></a> 263   # You can use net/http.rb 1.1 features (bundled with Ruby 1.6)
</span><span class="inferred1"><a name="line264"></a> 264   # by calling HTTP.version_1_1. Calling Net::HTTP.version_1_2
</span><span class="inferred0"><a name="line265"></a> 265   # allows you to use 1.2 features again.
</span><span class="inferred1"><a name="line266"></a> 266   # 
</span><span class="inferred0"><a name="line267"></a> 267   #     # example
</span><span class="inferred1"><a name="line268"></a> 268   #     Net::HTTP.start {|http1| ...(http1 has 1.2 features)... }
</span><span class="inferred0"><a name="line269"></a> 269   # 
</span><span class="inferred1"><a name="line270"></a> 270   #     Net::HTTP.version_1_1
</span><span class="inferred0"><a name="line271"></a> 271   #     Net::HTTP.start {|http2| ...(http2 has 1.1 features)... }
</span><span class="inferred1"><a name="line272"></a> 272   # 
</span><span class="inferred0"><a name="line273"></a> 273   #     Net::HTTP.version_1_2
</span><span class="inferred1"><a name="line274"></a> 274   #     Net::HTTP.start {|http3| ...(http3 has 1.2 features)... }
</span><span class="inferred0"><a name="line275"></a> 275   # 
</span><span class="inferred1"><a name="line276"></a> 276   # This function is NOT thread-safe.
</span><span class="inferred0"><a name="line277"></a> 277   #
</span><span class="marked1"><a name="line278"></a> 278   class HTTP &lt; Protocol
</span><span class="inferred0"><a name="line279"></a> 279 
</span><span class="inferred1"><a name="line280"></a> 280     # :stopdoc:
</span><span class="marked0"><a name="line281"></a> 281     Revision = %q$Revision: 13504 $.split[1]
</span><span class="marked1"><a name="line282"></a> 282     HTTPVersion = '1.1'
</span><span class="marked0"><a name="line283"></a> 283     @newimpl = true
</span><span class="inferred1"><a name="line284"></a> 284     # :startdoc:
</span><span class="inferred0"><a name="line285"></a> 285 
</span><span class="inferred1"><a name="line286"></a> 286     # Turns on net/http 1.2 (ruby 1.8) features.
</span><span class="inferred0"><a name="line287"></a> 287     # Defaults to ON in ruby 1.8.
</span><span class="inferred1"><a name="line288"></a> 288     #
</span><span class="inferred0"><a name="line289"></a> 289     # I strongly recommend to call this method always.
</span><span class="inferred1"><a name="line290"></a> 290     #
</span><span class="inferred0"><a name="line291"></a> 291     #   require 'net/http'
</span><span class="inferred1"><a name="line292"></a> 292     #   Net::HTTP.version_1_2
</span><span class="inferred0"><a name="line293"></a> 293     #
</span><span class="marked1"><a name="line294"></a> 294     def HTTP.version_1_2
</span><span class="uncovered0"><a name="line295"></a> 295       @newimpl = true
</span><span class="uncovered1"><a name="line296"></a> 296     end
</span><span class="inferred0"><a name="line297"></a> 297 
</span><span class="inferred1"><a name="line298"></a> 298     # Turns on net/http 1.1 (ruby 1.6) features.
</span><span class="inferred0"><a name="line299"></a> 299     # Defaults to OFF in ruby 1.8.
</span><span class="marked1"><a name="line300"></a> 300     def HTTP.version_1_1
</span><span class="uncovered0"><a name="line301"></a> 301       @newimpl = false
</span><span class="uncovered1"><a name="line302"></a> 302     end
</span><span class="inferred0"><a name="line303"></a> 303 
</span><span class="inferred1"><a name="line304"></a> 304     # true if net/http is in version 1.2 mode.
</span><span class="inferred0"><a name="line305"></a> 305     # Defaults to true.
</span><span class="marked1"><a name="line306"></a> 306     def HTTP.version_1_2?
</span><span class="marked0"><a name="line307"></a> 307       @newimpl
</span><span class="marked1"><a name="line308"></a> 308     end
</span><span class="inferred0"><a name="line309"></a> 309 
</span><span class="inferred1"><a name="line310"></a> 310     # true if net/http is in version 1.1 compatible mode.
</span><span class="inferred0"><a name="line311"></a> 311     # Defaults to true.
</span><span class="marked1"><a name="line312"></a> 312     def HTTP.version_1_1?
</span><span class="uncovered0"><a name="line313"></a> 313       not @newimpl
</span><span class="uncovered1"><a name="line314"></a> 314     end
</span><span class="inferred0"><a name="line315"></a> 315 
</span><span class="marked1"><a name="line316"></a> 316     class &lt;&lt; HTTP
</span><span class="marked0"><a name="line317"></a> 317       alias is_version_1_1? version_1_1?   #:nodoc:
</span><span class="marked1"><a name="line318"></a> 318       alias is_version_1_2? version_1_2?   #:nodoc:
</span><span class="inferred0"><a name="line319"></a> 319     end
</span><span class="inferred1"><a name="line320"></a> 320 
</span><span class="inferred0"><a name="line321"></a> 321     #
</span><span class="inferred1"><a name="line322"></a> 322     # short cut methods
</span><span class="inferred0"><a name="line323"></a> 323     #
</span><span class="inferred1"><a name="line324"></a> 324 
</span><span class="inferred0"><a name="line325"></a> 325     #
</span><span class="inferred1"><a name="line326"></a> 326     # Get body from target and output it to +$stdout+.  The
</span><span class="inferred0"><a name="line327"></a> 327     # target can either be specified as (+uri+), or as
</span><span class="inferred1"><a name="line328"></a> 328     # (+host+, +path+, +port+ = 80); so: 
</span><span class="inferred0"><a name="line329"></a> 329     #
</span><span class="inferred1"><a name="line330"></a> 330     #    Net::HTTP.get_print URI.parse('http://www.example.com/index.html')
</span><span class="inferred0"><a name="line331"></a> 331     #
</span><span class="inferred1"><a name="line332"></a> 332     # or:
</span><span class="inferred0"><a name="line333"></a> 333     #
</span><span class="inferred1"><a name="line334"></a> 334     #    Net::HTTP.get_print 'www.example.com', '/index.html'
</span><span class="inferred0"><a name="line335"></a> 335     #
</span><span class="marked1"><a name="line336"></a> 336     def HTTP.get_print(uri_or_host, path = nil, port = nil)
</span><span class="uncovered0"><a name="line337"></a> 337       get_response(uri_or_host, path, port) {|res|
</span><span class="uncovered1"><a name="line338"></a> 338         res.read_body do |chunk|
</span><span class="uncovered0"><a name="line339"></a> 339           $stdout.print chunk
</span><span class="uncovered1"><a name="line340"></a> 340         end
</span><span class="uncovered0"><a name="line341"></a> 341       }
</span><span class="uncovered1"><a name="line342"></a> 342       nil
</span><span class="uncovered0"><a name="line343"></a> 343     end
</span><span class="inferred1"><a name="line344"></a> 344 
</span><span class="inferred0"><a name="line345"></a> 345     # Send a GET request to the target and return the response
</span><span class="inferred1"><a name="line346"></a> 346     # as a string.  The target can either be specified as
</span><span class="inferred0"><a name="line347"></a> 347     # (+uri+), or as (+host+, +path+, +port+ = 80); so:
</span><span class="inferred1"><a name="line348"></a> 348     # 
</span><span class="inferred0"><a name="line349"></a> 349     #    print Net::HTTP.get(URI.parse('http://www.example.com/index.html'))
</span><span class="inferred1"><a name="line350"></a> 350     #
</span><span class="inferred0"><a name="line351"></a> 351     # or:
</span><span class="inferred1"><a name="line352"></a> 352     #
</span><span class="inferred0"><a name="line353"></a> 353     #    print Net::HTTP.get('www.example.com', '/index.html')
</span><span class="inferred1"><a name="line354"></a> 354     #
</span><span class="marked0"><a name="line355"></a> 355     def HTTP.get(uri_or_host, path = nil, port = nil)
</span><span class="uncovered1"><a name="line356"></a> 356       get_response(uri_or_host, path, port).body
</span><span class="uncovered0"><a name="line357"></a> 357     end
</span><span class="inferred1"><a name="line358"></a> 358 
</span><span class="inferred0"><a name="line359"></a> 359     # Send a GET request to the target and return the response
</span><span class="inferred1"><a name="line360"></a> 360     # as a Net::HTTPResponse object.  The target can either be specified as
</span><span class="inferred0"><a name="line361"></a> 361     # (+uri+), or as (+host+, +path+, +port+ = 80); so:
</span><span class="inferred1"><a name="line362"></a> 362     # 
</span><span class="inferred0"><a name="line363"></a> 363     #    res = Net::HTTP.get_response(URI.parse('http://www.example.com/index.html'))
</span><span class="inferred1"><a name="line364"></a> 364     #    print res.body
</span><span class="inferred0"><a name="line365"></a> 365     #
</span><span class="inferred1"><a name="line366"></a> 366     # or:
</span><span class="inferred0"><a name="line367"></a> 367     #
</span><span class="inferred1"><a name="line368"></a> 368     #    res = Net::HTTP.get_response('www.example.com', '/index.html')
</span><span class="inferred0"><a name="line369"></a> 369     #    print res.body
</span><span class="inferred1"><a name="line370"></a> 370     #
</span><span class="marked0"><a name="line371"></a> 371     def HTTP.get_response(uri_or_host, path = nil, port = nil, &amp;block)
</span><span class="uncovered1"><a name="line372"></a> 372       if path
</span><span class="uncovered0"><a name="line373"></a> 373         host = uri_or_host
</span><span class="uncovered1"><a name="line374"></a> 374         new(host, port || HTTP.default_port).start {|http|
</span><span class="uncovered0"><a name="line375"></a> 375           return http.request_get(path, &amp;block)
</span><span class="uncovered1"><a name="line376"></a> 376         }
</span><span class="uncovered0"><a name="line377"></a> 377       else
</span><span class="uncovered1"><a name="line378"></a> 378         uri = uri_or_host
</span><span class="uncovered0"><a name="line379"></a> 379         new(uri.host, uri.port).start {|http|
</span><span class="uncovered1"><a name="line380"></a> 380           return http.request_get(uri.request_uri, &amp;block)
</span><span class="uncovered0"><a name="line381"></a> 381         }
</span><span class="uncovered1"><a name="line382"></a> 382       end
</span><span class="uncovered0"><a name="line383"></a> 383     end
</span><span class="inferred1"><a name="line384"></a> 384 
</span><span class="inferred0"><a name="line385"></a> 385     # Posts HTML form data to the +URL+.
</span><span class="inferred1"><a name="line386"></a> 386     # Form data must be represented as a Hash of String to String, e.g:
</span><span class="inferred0"><a name="line387"></a> 387     #
</span><span class="inferred1"><a name="line388"></a> 388     #   { &quot;cmd&quot; =&gt; &quot;search&quot;, &quot;q&quot; =&gt; &quot;ruby&quot;, &quot;max&quot; =&gt; &quot;50&quot; }
</span><span class="inferred0"><a name="line389"></a> 389     #
</span><span class="inferred1"><a name="line390"></a> 390     # This method also does Basic Authentication iff +URL+.user exists.
</span><span class="inferred0"><a name="line391"></a> 391     #
</span><span class="inferred1"><a name="line392"></a> 392     # Example:
</span><span class="inferred0"><a name="line393"></a> 393     #
</span><span class="inferred1"><a name="line394"></a> 394     #   require 'net/http'
</span><span class="inferred0"><a name="line395"></a> 395     #   require 'uri'
</span><span class="inferred1"><a name="line396"></a> 396     #
</span><span class="inferred0"><a name="line397"></a> 397     #   HTTP.post_form URI.parse('http://www.example.com/search.cgi'),
</span><span class="inferred1"><a name="line398"></a> 398     #                  { &quot;q&quot; =&gt; &quot;ruby&quot;, &quot;max&quot; =&gt; &quot;50&quot; }
</span><span class="inferred0"><a name="line399"></a> 399     #
</span><span class="marked1"><a name="line400"></a> 400     def HTTP.post_form(url, params)
</span><span class="uncovered0"><a name="line401"></a> 401       req = Post.new(url.path)
</span><span class="uncovered1"><a name="line402"></a> 402       req.form_data = params
</span><span class="uncovered0"><a name="line403"></a> 403       req.basic_auth url.user, url.password if url.user
</span><span class="uncovered1"><a name="line404"></a> 404       new(url.host, url.port).start {|http|
</span><span class="uncovered0"><a name="line405"></a> 405         http.request(req)
</span><span class="uncovered1"><a name="line406"></a> 406       }
</span><span class="uncovered0"><a name="line407"></a> 407     end
</span><span class="inferred1"><a name="line408"></a> 408 
</span><span class="inferred0"><a name="line409"></a> 409     #
</span><span class="inferred1"><a name="line410"></a> 410     # HTTP session management
</span><span class="inferred0"><a name="line411"></a> 411     #
</span><span class="inferred1"><a name="line412"></a> 412 
</span><span class="inferred0"><a name="line413"></a> 413     # The default port to use for HTTP requests; defaults to 80.
</span><span class="marked1"><a name="line414"></a> 414     def HTTP.default_port
</span><span class="uncovered0"><a name="line415"></a> 415       http_default_port()
</span><span class="uncovered1"><a name="line416"></a> 416     end
</span><span class="inferred0"><a name="line417"></a> 417 
</span><span class="inferred1"><a name="line418"></a> 418     # The default port to use for HTTP requests; defaults to 80.
</span><span class="marked0"><a name="line419"></a> 419     def HTTP.http_default_port
</span><span class="marked1"><a name="line420"></a> 420       80
</span><span class="marked0"><a name="line421"></a> 421     end
</span><span class="inferred1"><a name="line422"></a> 422 
</span><span class="inferred0"><a name="line423"></a> 423     # The default port to use for HTTPS requests; defaults to 443.
</span><span class="marked1"><a name="line424"></a> 424     def HTTP.https_default_port
</span><span class="uncovered0"><a name="line425"></a> 425       443
</span><span class="uncovered1"><a name="line426"></a> 426     end
</span><span class="inferred0"><a name="line427"></a> 427 
</span><span class="marked1"><a name="line428"></a> 428     def HTTP.socket_type   #:nodoc: obsolete
</span><span class="uncovered0"><a name="line429"></a> 429       BufferedIO
</span><span class="uncovered1"><a name="line430"></a> 430     end
</span><span class="inferred0"><a name="line431"></a> 431 
</span><span class="inferred1"><a name="line432"></a> 432     # creates a new Net::HTTP object and opens its TCP connection and 
</span><span class="inferred0"><a name="line433"></a> 433     # HTTP session.  If the optional block is given, the newly 
</span><span class="inferred1"><a name="line434"></a> 434     # created Net::HTTP object is passed to it and closed when the 
</span><span class="inferred0"><a name="line435"></a> 435     # block finishes.  In this case, the return value of this method
</span><span class="inferred1"><a name="line436"></a> 436     # is the return value of the block.  If no block is given, the
</span><span class="inferred0"><a name="line437"></a> 437     # return value of this method is the newly created Net::HTTP object
</span><span class="inferred1"><a name="line438"></a> 438     # itself, and the caller is responsible for closing it upon completion.
</span><span class="marked0"><a name="line439"></a> 439     def HTTP.start(address, port = nil, p_addr = nil, p_port = nil, p_user = nil, p_pass = nil, &amp;block) # :yield: +http+
</span><span class="inferred1"><a name="line440"></a> 440       new(address, port, p_addr, p_port, p_user, p_pass).start(&amp;block)
</span><span class="inferred0"><a name="line441"></a> 441     end
</span><span class="inferred1"><a name="line442"></a> 442 
</span><span class="marked0"><a name="line443"></a> 443     class &lt;&lt; HTTP
</span><span class="marked1"><a name="line444"></a> 444       alias newobj new
</span><span class="inferred0"><a name="line445"></a> 445     end
</span><span class="inferred1"><a name="line446"></a> 446 
</span><span class="inferred0"><a name="line447"></a> 447     # Creates a new Net::HTTP object.
</span><span class="inferred1"><a name="line448"></a> 448     # If +proxy_addr+ is given, creates an Net::HTTP object with proxy support.
</span><span class="inferred0"><a name="line449"></a> 449     # This method does not open the TCP connection.
</span><span class="marked1"><a name="line450"></a> 450     def HTTP.new(address, port = nil, p_addr = nil, p_port = nil, p_user = nil, p_pass = nil)
</span><span class="marked0"><a name="line451"></a> 451       h = Proxy(p_addr, p_port, p_user, p_pass).newobj(address, port)
</span><span class="marked1"><a name="line452"></a> 452       h.instance_eval {
</span><span class="marked0"><a name="line453"></a> 453         @newimpl = ::Net::HTTP.version_1_2?
</span><span class="inferred1"><a name="line454"></a> 454       }
</span><span class="marked0"><a name="line455"></a> 455       h
</span><span class="inferred1"><a name="line456"></a> 456     end
</span><span class="inferred0"><a name="line457"></a> 457 
</span><span class="inferred1"><a name="line458"></a> 458     # Creates a new Net::HTTP object for the specified +address+.
</span><span class="inferred0"><a name="line459"></a> 459     # This method does not open the TCP connection.
</span><span class="marked1"><a name="line460"></a> 460     def initialize(address, port = nil)
</span><span class="marked0"><a name="line461"></a> 461       @address = address
</span><span class="marked1"><a name="line462"></a> 462       @port    = (port || HTTP.default_port)
</span><span class="marked0"><a name="line463"></a> 463       @curr_http_version = HTTPVersion
</span><span class="marked1"><a name="line464"></a> 464       @seems_1_0_server = false
</span><span class="marked0"><a name="line465"></a> 465       @close_on_empty_response = false
</span><span class="marked1"><a name="line466"></a> 466       @socket  = nil
</span><span class="marked0"><a name="line467"></a> 467       @started = false
</span><span class="marked1"><a name="line468"></a> 468       @open_timeout = nil
</span><span class="marked0"><a name="line469"></a> 469       @read_timeout = 60
</span><span class="marked1"><a name="line470"></a> 470       @debug_output = nil
</span><span class="marked0"><a name="line471"></a> 471       @use_ssl = false
</span><span class="marked1"><a name="line472"></a> 472       @ssl_context = nil
</span><span class="inferred0"><a name="line473"></a> 473     end
</span><span class="inferred1"><a name="line474"></a> 474 
</span><span class="marked0"><a name="line475"></a> 475     def inspect
</span><span class="uncovered1"><a name="line476"></a> 476       &quot;#&lt;#{self.class} #{@address}:#{@port} open=#{started?}&gt;&quot;
</span><span class="uncovered0"><a name="line477"></a> 477     end
</span><span class="inferred1"><a name="line478"></a> 478 
</span><span class="inferred0"><a name="line479"></a> 479     # *WARNING* This method causes serious security hole.
</span><span class="inferred1"><a name="line480"></a> 480     # Never use this method in production code.
</span><span class="inferred0"><a name="line481"></a> 481     #
</span><span class="inferred1"><a name="line482"></a> 482     # Set an output stream for debugging.
</span><span class="inferred0"><a name="line483"></a> 483     #
</span><span class="inferred1"><a name="line484"></a> 484     #   http = Net::HTTP.new
</span><span class="inferred0"><a name="line485"></a> 485     #   http.set_debug_output $stderr
</span><span class="inferred1"><a name="line486"></a> 486     #   http.start { .... }
</span><span class="inferred0"><a name="line487"></a> 487     #
</span><span class="marked1"><a name="line488"></a> 488     def set_debug_output(output)
</span><span class="uncovered0"><a name="line489"></a> 489       warn 'Net::HTTP#set_debug_output called after HTTP started' if started?
</span><span class="uncovered1"><a name="line490"></a> 490       @debug_output = output
</span><span class="uncovered0"><a name="line491"></a> 491     end
</span><span class="inferred1"><a name="line492"></a> 492 
</span><span class="inferred0"><a name="line493"></a> 493     # The host name to connect to.
</span><span class="marked1"><a name="line494"></a> 494     attr_reader :address
</span><span class="inferred0"><a name="line495"></a> 495 
</span><span class="inferred1"><a name="line496"></a> 496     # The port number to connect to.
</span><span class="marked0"><a name="line497"></a> 497     attr_reader :port
</span><span class="inferred1"><a name="line498"></a> 498 
</span><span class="inferred0"><a name="line499"></a> 499     # Seconds to wait until connection is opened.
</span><span class="inferred1"><a name="line500"></a> 500     # If the HTTP object cannot open a connection in this many seconds,
</span><span class="inferred0"><a name="line501"></a> 501     # it raises a TimeoutError exception.
</span><span class="marked1"><a name="line502"></a> 502     attr_accessor :open_timeout
</span><span class="inferred0"><a name="line503"></a> 503 
</span><span class="inferred1"><a name="line504"></a> 504     # Seconds to wait until reading one block (by one read(2) call).
</span><span class="inferred0"><a name="line505"></a> 505     # If the HTTP object cannot open a connection in this many seconds,
</span><span class="inferred1"><a name="line506"></a> 506     # it raises a TimeoutError exception.
</span><span class="marked0"><a name="line507"></a> 507     attr_reader :read_timeout
</span><span class="inferred1"><a name="line508"></a> 508 
</span><span class="inferred0"><a name="line509"></a> 509     # Setter for the read_timeout attribute.
</span><span class="marked1"><a name="line510"></a> 510     def read_timeout=(sec)
</span><span class="uncovered0"><a name="line511"></a> 511       @socket.read_timeout = sec if @socket
</span><span class="uncovered1"><a name="line512"></a> 512       @read_timeout = sec
</span><span class="uncovered0"><a name="line513"></a> 513     end
</span><span class="inferred1"><a name="line514"></a> 514 
</span><span class="inferred0"><a name="line515"></a> 515     # returns true if the HTTP session is started.
</span><span class="marked1"><a name="line516"></a> 516     def started?
</span><span class="marked0"><a name="line517"></a> 517       @started
</span><span class="marked1"><a name="line518"></a> 518     end
</span><span class="inferred0"><a name="line519"></a> 519 
</span><span class="marked1"><a name="line520"></a> 520     alias active? started?   #:nodoc: obsolete
</span><span class="inferred0"><a name="line521"></a> 521 
</span><span class="marked1"><a name="line522"></a> 522     attr_accessor :close_on_empty_response
</span><span class="inferred0"><a name="line523"></a> 523 
</span><span class="inferred1"><a name="line524"></a> 524     # returns true if use SSL/TLS with HTTP.
</span><span class="marked0"><a name="line525"></a> 525     def use_ssl?
</span><span class="uncovered1"><a name="line526"></a> 526       false   # redefined in net/https
</span><span class="uncovered0"><a name="line527"></a> 527     end
</span><span class="inferred1"><a name="line528"></a> 528 
</span><span class="inferred0"><a name="line529"></a> 529     # Opens TCP connection and HTTP session.
</span><span class="inferred1"><a name="line530"></a> 530     # 
</span><span class="inferred0"><a name="line531"></a> 531     # When this method is called with block, gives a HTTP object
</span><span class="inferred1"><a name="line532"></a> 532     # to the block and closes the TCP connection / HTTP session
</span><span class="inferred0"><a name="line533"></a> 533     # after the block executed.
</span><span class="inferred1"><a name="line534"></a> 534     #
</span><span class="inferred0"><a name="line535"></a> 535     # When called with a block, returns the return value of the
</span><span class="inferred1"><a name="line536"></a> 536     # block; otherwise, returns self.
</span><span class="inferred0"><a name="line537"></a> 537     #
</span><span class="marked1"><a name="line538"></a> 538     def start  # :yield: http
</span><span class="marked0"><a name="line539"></a> 539       raise IOError, 'HTTP session already opened' if @started
</span><span class="marked1"><a name="line540"></a> 540       if block_given?
</span><span class="marked0"><a name="line541"></a> 541         begin
</span><span class="marked1"><a name="line542"></a> 542           do_start
</span><span class="marked0"><a name="line543"></a> 543           return yield(self)
</span><span class="inferred1"><a name="line544"></a> 544         ensure
</span><span class="marked0"><a name="line545"></a> 545           do_finish
</span><span class="inferred1"><a name="line546"></a> 546         end
</span><span class="inferred0"><a name="line547"></a> 547       end
</span><span class="uncovered1"><a name="line548"></a> 548       do_start
</span><span class="uncovered0"><a name="line549"></a> 549       self
</span><span class="uncovered1"><a name="line550"></a> 550     end
</span><span class="inferred0"><a name="line551"></a> 551 
</span><span class="marked1"><a name="line552"></a> 552     def do_start
</span><span class="marked0"><a name="line553"></a> 553       connect
</span><span class="marked1"><a name="line554"></a> 554       @started = true
</span><span class="inferred0"><a name="line555"></a> 555     end
</span><span class="marked1"><a name="line556"></a> 556     private :do_start
</span><span class="inferred0"><a name="line557"></a> 557 
</span><span class="marked1"><a name="line558"></a> 558     def connect
</span><span class="marked0"><a name="line559"></a> 559       D &quot;opening connection to #{conn_address()}...&quot;
</span><span class="marked1"><a name="line560"></a> 560       s = timeout(@open_timeout) { TCPSocket.open(conn_address(), conn_port()) }
</span><span class="marked0"><a name="line561"></a> 561       D &quot;opened&quot;
</span><span class="marked1"><a name="line562"></a> 562       if use_ssl?
</span><span class="uncovered0"><a name="line563"></a> 563         unless @ssl_context.verify_mode
</span><span class="uncovered1"><a name="line564"></a> 564           warn &quot;warning: peer certificate won't be verified in this SSL session&quot;
</span><span class="uncovered0"><a name="line565"></a> 565           @ssl_context.verify_mode = OpenSSL::SSL::VERIFY_NONE
</span><span class="uncovered1"><a name="line566"></a> 566         end
</span><span class="uncovered0"><a name="line567"></a> 567         s = OpenSSL::SSL::SSLSocket.new(s, @ssl_context)
</span><span class="uncovered1"><a name="line568"></a> 568         s.sync_close = true
</span><span class="uncovered0"><a name="line569"></a> 569       end
</span><span class="marked1"><a name="line570"></a> 570       @socket = BufferedIO.new(s)
</span><span class="marked0"><a name="line571"></a> 571       @socket.read_timeout = @read_timeout
</span><span class="marked1"><a name="line572"></a> 572       @socket.debug_output = @debug_output
</span><span class="marked0"><a name="line573"></a> 573       if use_ssl?
</span><span class="uncovered1"><a name="line574"></a> 574         if proxy?
</span><span class="uncovered0"><a name="line575"></a> 575           @socket.writeline sprintf('CONNECT %s:%s HTTP/%s',
</span><span class="uncovered1"><a name="line576"></a> 576                                     @address, @port, HTTPVersion)
</span><span class="uncovered0"><a name="line577"></a> 577           @socket.writeline &quot;Host: #{@address}:#{@port}&quot;
</span><span class="uncovered1"><a name="line578"></a> 578           if proxy_user
</span><span class="uncovered0"><a name="line579"></a> 579             credential = [&quot;#{proxy_user}:#{proxy_pass}&quot;].pack('m')
</span><span class="uncovered1"><a name="line580"></a> 580             credential.delete!(&quot;\r\n&quot;)
</span><span class="uncovered0"><a name="line581"></a> 581             @socket.writeline &quot;Proxy-Authorization: Basic #{credential}&quot;
</span><span class="uncovered1"><a name="line582"></a> 582           end
</span><span class="uncovered0"><a name="line583"></a> 583           @socket.writeline ''
</span><span class="uncovered1"><a name="line584"></a> 584           HTTPResponse.read_new(@socket).value
</span><span class="uncovered0"><a name="line585"></a> 585         end
</span><span class="uncovered1"><a name="line586"></a> 586         s.connect
</span><span class="uncovered0"><a name="line587"></a> 587         if @ssl_context.verify_mode != OpenSSL::SSL::VERIFY_NONE
</span><span class="uncovered1"><a name="line588"></a> 588           s.post_connection_check(@address)
</span><span class="uncovered0"><a name="line589"></a> 589         end
</span><span class="uncovered1"><a name="line590"></a> 590       end
</span><span class="marked0"><a name="line591"></a> 591       on_connect
</span><span class="inferred1"><a name="line592"></a> 592     end
</span><span class="marked0"><a name="line593"></a> 593     private :connect
</span><span class="inferred1"><a name="line594"></a> 594 
</span><span class="marked0"><a name="line595"></a> 595     def on_connect
</span><span class="marked1"><a name="line596"></a> 596     end
</span><span class="marked0"><a name="line597"></a> 597     private :on_connect
</span><span class="inferred1"><a name="line598"></a> 598 
</span><span class="inferred0"><a name="line599"></a> 599     # Finishes HTTP session and closes TCP connection.
</span><span class="inferred1"><a name="line600"></a> 600     # Raises IOError if not started.
</span><span class="marked0"><a name="line601"></a> 601     def finish
</span><span class="uncovered1"><a name="line602"></a> 602       raise IOError, 'HTTP session not yet started' unless started?
</span><span class="uncovered0"><a name="line603"></a> 603       do_finish
</span><span class="uncovered1"><a name="line604"></a> 604     end
</span><span class="inferred0"><a name="line605"></a> 605 
</span><span class="marked1"><a name="line606"></a> 606     def do_finish
</span><span class="marked0"><a name="line607"></a> 607       @started = false
</span><span class="marked1"><a name="line608"></a> 608       @socket.close if @socket and not @socket.closed?
</span><span class="marked0"><a name="line609"></a> 609       @socket = nil
</span><span class="inferred1"><a name="line610"></a> 610     end
</span><span class="marked0"><a name="line611"></a> 611     private :do_finish
</span><span class="inferred1"><a name="line612"></a> 612 
</span><span class="inferred0"><a name="line613"></a> 613     #
</span><span class="inferred1"><a name="line614"></a> 614     # proxy
</span><span class="inferred0"><a name="line615"></a> 615     #
</span><span class="inferred1"><a name="line616"></a> 616 
</span><span class="marked0"><a name="line617"></a> 617     public
</span><span class="inferred1"><a name="line618"></a> 618 
</span><span class="inferred0"><a name="line619"></a> 619     # no proxy
</span><span class="marked1"><a name="line620"></a> 620     @is_proxy_class = false
</span><span class="marked0"><a name="line621"></a> 621     @proxy_addr = nil
</span><span class="marked1"><a name="line622"></a> 622     @proxy_port = nil
</span><span class="marked0"><a name="line623"></a> 623     @proxy_user = nil
</span><span class="marked1"><a name="line624"></a> 624     @proxy_pass = nil
</span><span class="inferred0"><a name="line625"></a> 625 
</span><span class="inferred1"><a name="line626"></a> 626     # Creates an HTTP proxy class.
</span><span class="inferred0"><a name="line627"></a> 627     # Arguments are address/port of proxy host and username/password
</span><span class="inferred1"><a name="line628"></a> 628     # if authorization on proxy server is required.
</span><span class="inferred0"><a name="line629"></a> 629     # You can replace the HTTP class with created proxy class.
</span><span class="inferred1"><a name="line630"></a> 630     # 
</span><span class="inferred0"><a name="line631"></a> 631     # If ADDRESS is nil, this method returns self (Net::HTTP).
</span><span class="inferred1"><a name="line632"></a> 632     # 
</span><span class="inferred0"><a name="line633"></a> 633     #     # Example
</span><span class="inferred1"><a name="line634"></a> 634     #     proxy_class = Net::HTTP::Proxy('proxy.example.com', 8080)
</span><span class="inferred0"><a name="line635"></a> 635     #                     :
</span><span class="inferred1"><a name="line636"></a> 636     #     proxy_class.start('www.ruby-lang.org') {|http|
</span><span class="inferred0"><a name="line637"></a> 637     #       # connecting proxy.foo.org:8080
</span><span class="inferred1"><a name="line638"></a> 638     #                     :
</span><span class="inferred0"><a name="line639"></a> 639     #     }
</span><span class="inferred1"><a name="line640"></a> 640     # 
</span><span class="marked0"><a name="line641"></a> 641     def HTTP.Proxy(p_addr, p_port = nil, p_user = nil, p_pass = nil)
</span><span class="marked1"><a name="line642"></a> 642       return self unless p_addr
</span><span class="uncovered0"><a name="line643"></a> 643       delta = ProxyDelta
</span><span class="uncovered1"><a name="line644"></a> 644       proxyclass = Class.new(self)
</span><span class="uncovered0"><a name="line645"></a> 645       proxyclass.module_eval {
</span><span class="uncovered1"><a name="line646"></a> 646         include delta
</span><span class="uncovered0"><a name="line647"></a> 647         # with proxy
</span><span class="uncovered1"><a name="line648"></a> 648         @is_proxy_class = true
</span><span class="uncovered0"><a name="line649"></a> 649         @proxy_address = p_addr
</span><span class="uncovered1"><a name="line650"></a> 650         @proxy_port    = p_port || default_port()
</span><span class="uncovered0"><a name="line651"></a> 651         @proxy_user    = p_user
</span><span class="uncovered1"><a name="line652"></a> 652         @proxy_pass    = p_pass
</span><span class="uncovered0"><a name="line653"></a> 653       }
</span><span class="uncovered1"><a name="line654"></a> 654       proxyclass
</span><span class="uncovered0"><a name="line655"></a> 655     end
</span><span class="inferred1"><a name="line656"></a> 656 
</span><span class="marked0"><a name="line657"></a> 657     class &lt;&lt; HTTP
</span><span class="inferred1"><a name="line658"></a> 658       # returns true if self is a class which was created by HTTP::Proxy.
</span><span class="marked0"><a name="line659"></a> 659       def proxy_class?
</span><span class="uncovered1"><a name="line660"></a> 660         @is_proxy_class
</span><span class="uncovered0"><a name="line661"></a> 661       end
</span><span class="inferred1"><a name="line662"></a> 662 
</span><span class="marked0"><a name="line663"></a> 663       attr_reader :proxy_address
</span><span class="marked1"><a name="line664"></a> 664       attr_reader :proxy_port
</span><span class="marked0"><a name="line665"></a> 665       attr_reader :proxy_user
</span><span class="marked1"><a name="line666"></a> 666       attr_reader :proxy_pass
</span><span class="inferred0"><a name="line667"></a> 667     end
</span><span class="inferred1"><a name="line668"></a> 668 
</span><span class="inferred0"><a name="line669"></a> 669     # True if self is a HTTP proxy class.
</span><span class="marked1"><a name="line670"></a> 670     def proxy?
</span><span class="uncovered0"><a name="line671"></a> 671       self.class.proxy_class?
</span><span class="uncovered1"><a name="line672"></a> 672     end
</span><span class="inferred0"><a name="line673"></a> 673 
</span><span class="inferred1"><a name="line674"></a> 674     # Address of proxy host. If self does not use a proxy, nil.
</span><span class="marked0"><a name="line675"></a> 675     def proxy_address
</span><span class="uncovered1"><a name="line676"></a> 676       self.class.proxy_address
</span><span class="uncovered0"><a name="line677"></a> 677     end
</span><span class="inferred1"><a name="line678"></a> 678 
</span><span class="inferred0"><a name="line679"></a> 679     # Port number of proxy host. If self does not use a proxy, nil.
</span><span class="marked1"><a name="line680"></a> 680     def proxy_port
</span><span class="uncovered0"><a name="line681"></a> 681       self.class.proxy_port
</span><span class="uncovered1"><a name="line682"></a> 682     end
</span><span class="inferred0"><a name="line683"></a> 683 
</span><span class="inferred1"><a name="line684"></a> 684     # User name for accessing proxy. If self does not use a proxy, nil.
</span><span class="marked0"><a name="line685"></a> 685     def proxy_user
</span><span class="marked1"><a name="line686"></a> 686       self.class.proxy_user
</span><span class="marked0"><a name="line687"></a> 687     end
</span><span class="inferred1"><a name="line688"></a> 688 
</span><span class="inferred0"><a name="line689"></a> 689     # User password for accessing proxy. If self does not use a proxy, nil.
</span><span class="marked1"><a name="line690"></a> 690     def proxy_pass
</span><span class="uncovered0"><a name="line691"></a> 691       self.class.proxy_pass
</span><span class="uncovered1"><a name="line692"></a> 692     end
</span><span class="inferred0"><a name="line693"></a> 693 
</span><span class="marked1"><a name="line694"></a> 694     alias proxyaddr proxy_address   #:nodoc: obsolete
</span><span class="marked0"><a name="line695"></a> 695     alias proxyport proxy_port      #:nodoc: obsolete
</span><span class="inferred1"><a name="line696"></a> 696 
</span><span class="marked0"><a name="line697"></a> 697     private
</span><span class="inferred1"><a name="line698"></a> 698 
</span><span class="inferred0"><a name="line699"></a> 699     # without proxy
</span><span class="inferred1"><a name="line700"></a> 700 
</span><span class="marked0"><a name="line701"></a> 701     def conn_address
</span><span class="marked1"><a name="line702"></a> 702       address()
</span><span class="marked0"><a name="line703"></a> 703     end
</span><span class="inferred1"><a name="line704"></a> 704 
</span><span class="marked0"><a name="line705"></a> 705     def conn_port
</span><span class="marked1"><a name="line706"></a> 706       port()
</span><span class="marked0"><a name="line707"></a> 707     end
</span><span class="inferred1"><a name="line708"></a> 708 
</span><span class="marked0"><a name="line709"></a> 709     def edit_path(path)
</span><span class="marked1"><a name="line710"></a> 710       path
</span><span class="marked0"><a name="line711"></a> 711     end
</span><span class="inferred1"><a name="line712"></a> 712 
</span><span class="marked0"><a name="line713"></a> 713     module ProxyDelta   #:nodoc: internal use only
</span><span class="marked1"><a name="line714"></a> 714       private
</span><span class="inferred0"><a name="line715"></a> 715 
</span><span class="marked1"><a name="line716"></a> 716       def conn_address
</span><span class="uncovered0"><a name="line717"></a> 717         proxy_address()
</span><span class="uncovered1"><a name="line718"></a> 718       end
</span><span class="inferred0"><a name="line719"></a> 719 
</span><span class="marked1"><a name="line720"></a> 720       def conn_port
</span><span class="uncovered0"><a name="line721"></a> 721         proxy_port()
</span><span class="uncovered1"><a name="line722"></a> 722       end
</span><span class="inferred0"><a name="line723"></a> 723 
</span><span class="marked1"><a name="line724"></a> 724       def edit_path(path)
</span><span class="uncovered0"><a name="line725"></a> 725         use_ssl? ? path : &quot;http://#{addr_port()}#{path}&quot;
</span><span class="uncovered1"><a name="line726"></a> 726       end
</span><span class="uncovered0"><a name="line727"></a> 727     end
</span><span class="inferred1"><a name="line728"></a> 728 
</span><span class="inferred0"><a name="line729"></a> 729     #
</span><span class="inferred1"><a name="line730"></a> 730     # HTTP operations
</span><span class="inferred0"><a name="line731"></a> 731     #
</span><span class="inferred1"><a name="line732"></a> 732 
</span><span class="marked0"><a name="line733"></a> 733     public
</span><span class="inferred1"><a name="line734"></a> 734 
</span><span class="inferred0"><a name="line735"></a> 735     # Gets data from +path+ on the connected-to host.
</span><span class="inferred1"><a name="line736"></a> 736     # +header+ must be a Hash like { 'Accept' =&gt; '*/*', ... }.
</span><span class="inferred0"><a name="line737"></a> 737     #
</span><span class="inferred1"><a name="line738"></a> 738     # In version 1.1 (ruby 1.6), this method returns a pair of objects,
</span><span class="inferred0"><a name="line739"></a> 739     # a Net::HTTPResponse object and the entity body string.
</span><span class="inferred1"><a name="line740"></a> 740     # In version 1.2 (ruby 1.8), this method returns a Net::HTTPResponse
</span><span class="inferred0"><a name="line741"></a> 741     # object.
</span><span class="inferred1"><a name="line742"></a> 742     #
</span><span class="inferred0"><a name="line743"></a> 743     # If called with a block, yields each fragment of the
</span><span class="inferred1"><a name="line744"></a> 744     # entity body in turn as a string as it is read from
</span><span class="inferred0"><a name="line745"></a> 745     # the socket.  Note that in this case, the returned response
</span><span class="inferred1"><a name="line746"></a> 746     # object will *not* contain a (meaningful) body.
</span><span class="inferred0"><a name="line747"></a> 747     #
</span><span class="inferred1"><a name="line748"></a> 748     # +dest+ argument is obsolete.
</span><span class="inferred0"><a name="line749"></a> 749     # It still works but you must not use it.
</span><span class="inferred1"><a name="line750"></a> 750     #
</span><span class="inferred0"><a name="line751"></a> 751     # In version 1.1, this method might raise an exception for 
</span><span class="inferred1"><a name="line752"></a> 752     # 3xx (redirect). In this case you can get a HTTPResponse object
</span><span class="inferred0"><a name="line753"></a> 753     # by &quot;anException.response&quot;.
</span><span class="inferred1"><a name="line754"></a> 754     #
</span><span class="inferred0"><a name="line755"></a> 755     # In version 1.2, this method never raises exception.
</span><span class="inferred1"><a name="line756"></a> 756     #
</span><span class="inferred0"><a name="line757"></a> 757     #     # version 1.1 (bundled with Ruby 1.6)
</span><span class="inferred1"><a name="line758"></a> 758     #     response, body = http.get('/index.html')
</span><span class="inferred0"><a name="line759"></a> 759     #
</span><span class="inferred1"><a name="line760"></a> 760     #     # version 1.2 (bundled with Ruby 1.8 or later)
</span><span class="inferred0"><a name="line761"></a> 761     #     response = http.get('/index.html')
</span><span class="inferred1"><a name="line762"></a> 762     #     
</span><span class="inferred0"><a name="line763"></a> 763     #     # using block
</span><span class="inferred1"><a name="line764"></a> 764     #     File.open('result.txt', 'w') {|f|
</span><span class="inferred0"><a name="line765"></a> 765     #       http.get('/~foo/') do |str|
</span><span class="inferred1"><a name="line766"></a> 766     #         f.write str
</span><span class="inferred0"><a name="line767"></a> 767     #       end
</span><span class="inferred1"><a name="line768"></a> 768     #     }
</span><span class="inferred0"><a name="line769"></a> 769     #
</span><span class="marked1"><a name="line770"></a> 770     def get(path, initheader = nil, dest = nil, &amp;block) # :yield: +body_segment+
</span><span class="marked0"><a name="line771"></a> 771       res = nil
</span><span class="marked1"><a name="line772"></a> 772       request(Get.new(path, initheader)) {|r|
</span><span class="marked0"><a name="line773"></a> 773         r.read_body dest, &amp;block
</span><span class="marked1"><a name="line774"></a> 774         res = r
</span><span class="inferred0"><a name="line775"></a> 775       }
</span><span class="marked1"><a name="line776"></a> 776       unless @newimpl
</span><span class="uncovered0"><a name="line777"></a> 777         res.value
</span><span class="uncovered1"><a name="line778"></a> 778         return res, res.body
</span><span class="uncovered0"><a name="line779"></a> 779       end
</span><span class="inferred1"><a name="line780"></a> 780 
</span><span class="marked0"><a name="line781"></a> 781       res
</span><span class="inferred1"><a name="line782"></a> 782     end
</span><span class="inferred0"><a name="line783"></a> 783 
</span><span class="inferred1"><a name="line784"></a> 784     # Gets only the header from +path+ on the connected-to host.
</span><span class="inferred0"><a name="line785"></a> 785     # +header+ is a Hash like { 'Accept' =&gt; '*/*', ... }.
</span><span class="inferred1"><a name="line786"></a> 786     # 
</span><span class="inferred0"><a name="line787"></a> 787     # This method returns a Net::HTTPResponse object.
</span><span class="inferred1"><a name="line788"></a> 788     # 
</span><span class="inferred0"><a name="line789"></a> 789     # In version 1.1, this method might raise an exception for 
</span><span class="inferred1"><a name="line790"></a> 790     # 3xx (redirect). On the case you can get a HTTPResponse object
</span><span class="inferred0"><a name="line791"></a> 791     # by &quot;anException.response&quot;.
</span><span class="inferred1"><a name="line792"></a> 792     # In version 1.2, this method never raises an exception.
</span><span class="inferred0"><a name="line793"></a> 793     # 
</span><span class="inferred1"><a name="line794"></a> 794     #     response = nil
</span><span class="inferred0"><a name="line795"></a> 795     #     Net::HTTP.start('some.www.server', 80) {|http|
</span><span class="inferred1"><a name="line796"></a> 796     #       response = http.head('/index.html')
</span><span class="inferred0"><a name="line797"></a> 797     #     }
</span><span class="inferred1"><a name="line798"></a> 798     #     p response['content-type']
</span><span class="inferred0"><a name="line799"></a> 799     #
</span><span class="marked1"><a name="line800"></a> 800     def head(path, initheader = nil) 
</span><span class="uncovered0"><a name="line801"></a> 801       res = request(Head.new(path, initheader))
</span><span class="uncovered1"><a name="line802"></a> 802       res.value unless @newimpl
</span><span class="uncovered0"><a name="line803"></a> 803       res
</span><span class="uncovered1"><a name="line804"></a> 804     end
</span><span class="inferred0"><a name="line805"></a> 805 
</span><span class="inferred1"><a name="line806"></a> 806     # Posts +data+ (must be a String) to +path+. +header+ must be a Hash
</span><span class="inferred0"><a name="line807"></a> 807     # like { 'Accept' =&gt; '*/*', ... }.
</span><span class="inferred1"><a name="line808"></a> 808     # 
</span><span class="inferred0"><a name="line809"></a> 809     # In version 1.1 (ruby 1.6), this method returns a pair of objects, a
</span><span class="inferred1"><a name="line810"></a> 810     # Net::HTTPResponse object and an entity body string.
</span><span class="inferred0"><a name="line811"></a> 811     # In version 1.2 (ruby 1.8), this method returns a Net::HTTPResponse object.
</span><span class="inferred1"><a name="line812"></a> 812     # 
</span><span class="inferred0"><a name="line813"></a> 813     # If called with a block, yields each fragment of the
</span><span class="inferred1"><a name="line814"></a> 814     # entity body in turn as a string as it are read from
</span><span class="inferred0"><a name="line815"></a> 815     # the socket.  Note that in this case, the returned response
</span><span class="inferred1"><a name="line816"></a> 816     # object will *not* contain a (meaningful) body.
</span><span class="inferred0"><a name="line817"></a> 817     #
</span><span class="inferred1"><a name="line818"></a> 818     # +dest+ argument is obsolete.
</span><span class="inferred0"><a name="line819"></a> 819     # It still works but you must not use it.
</span><span class="inferred1"><a name="line820"></a> 820     # 
</span><span class="inferred0"><a name="line821"></a> 821     # In version 1.1, this method might raise an exception for 
</span><span class="inferred1"><a name="line822"></a> 822     # 3xx (redirect). In this case you can get an HTTPResponse object
</span><span class="inferred0"><a name="line823"></a> 823     # by &quot;anException.response&quot;.
</span><span class="inferred1"><a name="line824"></a> 824     # In version 1.2, this method never raises exception.
</span><span class="inferred0"><a name="line825"></a> 825     # 
</span><span class="inferred1"><a name="line826"></a> 826     #     # version 1.1
</span><span class="inferred0"><a name="line827"></a> 827     #     response, body = http.post('/cgi-bin/search.rb', 'query=foo')
</span><span class="inferred1"><a name="line828"></a> 828     # 
</span><span class="inferred0"><a name="line829"></a> 829     #     # version 1.2
</span><span class="inferred1"><a name="line830"></a> 830     #     response = http.post('/cgi-bin/search.rb', 'query=foo')
</span><span class="inferred0"><a name="line831"></a> 831     # 
</span><span class="inferred1"><a name="line832"></a> 832     #     # using block
</span><span class="inferred0"><a name="line833"></a> 833     #     File.open('result.txt', 'w') {|f|
</span><span class="inferred1"><a name="line834"></a> 834     #       http.post('/cgi-bin/search.rb', 'query=foo') do |str|
</span><span class="inferred0"><a name="line835"></a> 835     #         f.write str
</span><span class="inferred1"><a name="line836"></a> 836     #       end
</span><span class="inferred0"><a name="line837"></a> 837     #     }
</span><span class="inferred1"><a name="line838"></a> 838     #
</span><span class="inferred0"><a name="line839"></a> 839     # You should set Content-Type: header field for POST.
</span><span class="inferred1"><a name="line840"></a> 840     # If no Content-Type: field given, this method uses
</span><span class="inferred0"><a name="line841"></a> 841     # &quot;application/x-www-form-urlencoded&quot; by default.
</span><span class="inferred1"><a name="line842"></a> 842     #
</span><span class="marked0"><a name="line843"></a> 843     def post(path, data, initheader = nil, dest = nil, &amp;block) # :yield: +body_segment+
</span><span class="marked1"><a name="line844"></a> 844       res = nil
</span><span class="marked0"><a name="line845"></a> 845       request(Post.new(path, initheader), data) {|r|
</span><span class="marked1"><a name="line846"></a> 846         r.read_body dest, &amp;block
</span><span class="marked0"><a name="line847"></a> 847         res = r
</span><span class="inferred1"><a name="line848"></a> 848       }
</span><span class="marked0"><a name="line849"></a> 849       unless @newimpl
</span><span class="uncovered1"><a name="line850"></a> 850         res.value
</span><span class="uncovered0"><a name="line851"></a> 851         return res, res.body
</span><span class="uncovered1"><a name="line852"></a> 852       end
</span><span class="marked0"><a name="line853"></a> 853       res
</span><span class="inferred1"><a name="line854"></a> 854     end
</span><span class="inferred0"><a name="line855"></a> 855 
</span><span class="marked1"><a name="line856"></a> 856     def put(path, data, initheader = nil)   #:nodoc:
</span><span class="marked0"><a name="line857"></a> 857       res = request(Put.new(path, initheader), data)
</span><span class="marked1"><a name="line858"></a> 858       res.value unless @newimpl
</span><span class="marked0"><a name="line859"></a> 859       res
</span><span class="inferred1"><a name="line860"></a> 860     end
</span><span class="inferred0"><a name="line861"></a> 861 
</span><span class="inferred1"><a name="line862"></a> 862     # Sends a PROPPATCH request to the +path+ and gets a response,
</span><span class="inferred0"><a name="line863"></a> 863     # as an HTTPResponse object.
</span><span class="marked1"><a name="line864"></a> 864     def proppatch(path, body, initheader = nil)
</span><span class="uncovered0"><a name="line865"></a> 865       request(Proppatch.new(path, initheader), body)
</span><span class="uncovered1"><a name="line866"></a> 866     end
</span><span class="inferred0"><a name="line867"></a> 867 
</span><span class="inferred1"><a name="line868"></a> 868     # Sends a LOCK request to the +path+ and gets a response,
</span><span class="inferred0"><a name="line869"></a> 869     # as an HTTPResponse object.
</span><span class="marked1"><a name="line870"></a> 870     def lock(path, body, initheader = nil)
</span><span class="uncovered0"><a name="line871"></a> 871       request(Lock.new(path, initheader), body)
</span><span class="uncovered1"><a name="line872"></a> 872     end
</span><span class="inferred0"><a name="line873"></a> 873 
</span><span class="inferred1"><a name="line874"></a> 874     # Sends a UNLOCK request to the +path+ and gets a response,
</span><span class="inferred0"><a name="line875"></a> 875     # as an HTTPResponse object.
</span><span class="marked1"><a name="line876"></a> 876     def unlock(path, body, initheader = nil)
</span><span class="uncovered0"><a name="line877"></a> 877       request(Unlock.new(path, initheader), body)
</span><span class="uncovered1"><a name="line878"></a> 878     end
</span><span class="inferred0"><a name="line879"></a> 879 
</span><span class="inferred1"><a name="line880"></a> 880     # Sends a OPTIONS request to the +path+ and gets a response,
</span><span class="inferred0"><a name="line881"></a> 881     # as an HTTPResponse object.
</span><span class="marked1"><a name="line882"></a> 882     def options(path, initheader = nil)
</span><span class="uncovered0"><a name="line883"></a> 883       request(Options.new(path, initheader))
</span><span class="uncovered1"><a name="line884"></a> 884     end
</span><span class="inferred0"><a name="line885"></a> 885 
</span><span class="inferred1"><a name="line886"></a> 886     # Sends a PROPFIND request to the +path+ and gets a response,
</span><span class="inferred0"><a name="line887"></a> 887     # as an HTTPResponse object.
</span><span class="marked1"><a name="line888"></a> 888     def propfind(path, body = nil, initheader = {'Depth' =&gt; '0'})
</span><span class="uncovered0"><a name="line889"></a> 889       request(Propfind.new(path, initheader), body)
</span><span class="uncovered1"><a name="line890"></a> 890     end
</span><span class="inferred0"><a name="line891"></a> 891 
</span><span class="inferred1"><a name="line892"></a> 892     # Sends a DELETE request to the +path+ and gets a response,
</span><span class="inferred0"><a name="line893"></a> 893     # as an HTTPResponse object.
</span><span class="marked1"><a name="line894"></a> 894     def delete(path, initheader = {'Depth' =&gt; 'Infinity'})
</span><span class="marked0"><a name="line895"></a> 895       request(Delete.new(path, initheader))
</span><span class="marked1"><a name="line896"></a> 896     end
</span><span class="inferred0"><a name="line897"></a> 897 
</span><span class="inferred1"><a name="line898"></a> 898     # Sends a MOVE request to the +path+ and gets a response,
</span><span class="inferred0"><a name="line899"></a> 899     # as an HTTPResponse object.
</span><span class="marked1"><a name="line900"></a> 900     def move(path, initheader = nil)
</span><span class="uncovered0"><a name="line901"></a> 901       request(Move.new(path, initheader))
</span><span class="uncovered1"><a name="line902"></a> 902     end
</span><span class="inferred0"><a name="line903"></a> 903 
</span><span class="inferred1"><a name="line904"></a> 904     # Sends a COPY request to the +path+ and gets a response,
</span><span class="inferred0"><a name="line905"></a> 905     # as an HTTPResponse object.
</span><span class="marked1"><a name="line906"></a> 906     def copy(path, initheader = nil)
</span><span class="uncovered0"><a name="line907"></a> 907       request(Copy.new(path, initheader))
</span><span class="uncovered1"><a name="line908"></a> 908     end
</span><span class="inferred0"><a name="line909"></a> 909 
</span><span class="inferred1"><a name="line910"></a> 910     # Sends a MKCOL request to the +path+ and gets a response,
</span><span class="inferred0"><a name="line911"></a> 911     # as an HTTPResponse object.
</span><span class="marked1"><a name="line912"></a> 912     def mkcol(path, body = nil, initheader = nil)
</span><span class="uncovered0"><a name="line913"></a> 913       request(Mkcol.new(path, initheader), body)
</span><span class="uncovered1"><a name="line914"></a> 914     end
</span><span class="inferred0"><a name="line915"></a> 915 
</span><span class="inferred1"><a name="line916"></a> 916     # Sends a TRACE request to the +path+ and gets a response,
</span><span class="inferred0"><a name="line917"></a> 917     # as an HTTPResponse object.
</span><span class="marked1"><a name="line918"></a> 918     def trace(path, initheader = nil)
</span><span class="uncovered0"><a name="line919"></a> 919       request(Trace.new(path, initheader))
</span><span class="uncovered1"><a name="line920"></a> 920     end
</span><span class="inferred0"><a name="line921"></a> 921 
</span><span class="inferred1"><a name="line922"></a> 922     # Sends a GET request to the +path+ and gets a response,
</span><span class="inferred0"><a name="line923"></a> 923     # as an HTTPResponse object.
</span><span class="inferred1"><a name="line924"></a> 924     # 
</span><span class="inferred0"><a name="line925"></a> 925     # When called with a block, yields an HTTPResponse object.
</span><span class="inferred1"><a name="line926"></a> 926     # The body of this response will not have been read yet;
</span><span class="inferred0"><a name="line927"></a> 927     # the caller can process it using HTTPResponse#read_body,
</span><span class="inferred1"><a name="line928"></a> 928     # if desired.
</span><span class="inferred0"><a name="line929"></a> 929     #
</span><span class="inferred1"><a name="line930"></a> 930     # Returns the response.
</span><span class="inferred0"><a name="line931"></a> 931     # 
</span><span class="inferred1"><a name="line932"></a> 932     # This method never raises Net::* exceptions.
</span><span class="inferred0"><a name="line933"></a> 933     # 
</span><span class="inferred1"><a name="line934"></a> 934     #     response = http.request_get('/index.html')
</span><span class="inferred0"><a name="line935"></a> 935     #     # The entity body is already read here.
</span><span class="inferred1"><a name="line936"></a> 936     #     p response['content-type']
</span><span class="inferred0"><a name="line937"></a> 937     #     puts response.body
</span><span class="inferred1"><a name="line938"></a> 938     # 
</span><span class="inferred0"><a name="line939"></a> 939     #     # using block
</span><span class="inferred1"><a name="line940"></a> 940     #     http.request_get('/index.html') {|response|
</span><span class="inferred0"><a name="line941"></a> 941     #       p response['content-type']
</span><span class="inferred1"><a name="line942"></a> 942     #       response.read_body do |str|   # read body now
</span><span class="inferred0"><a name="line943"></a> 943     #         print str
</span><span class="inferred1"><a name="line944"></a> 944     #       end
</span><span class="inferred0"><a name="line945"></a> 945     #     }
</span><span class="inferred1"><a name="line946"></a> 946     #
</span><span class="marked0"><a name="line947"></a> 947     def request_get(path, initheader = nil, &amp;block) # :yield: +response+
</span><span class="inferred1"><a name="line948"></a> 948       request(Get.new(path, initheader), &amp;block)
</span><span class="inferred0"><a name="line949"></a> 949     end
</span><span class="inferred1"><a name="line950"></a> 950 
</span><span class="inferred0"><a name="line951"></a> 951     # Sends a HEAD request to the +path+ and gets a response,
</span><span class="inferred1"><a name="line952"></a> 952     # as an HTTPResponse object.
</span><span class="inferred0"><a name="line953"></a> 953     #
</span><span class="inferred1"><a name="line954"></a> 954     # Returns the response.
</span><span class="inferred0"><a name="line955"></a> 955     # 
</span><span class="inferred1"><a name="line956"></a> 956     # This method never raises Net::* exceptions.
</span><span class="inferred0"><a name="line957"></a> 957     # 
</span><span class="inferred1"><a name="line958"></a> 958     #     response = http.request_head('/index.html')
</span><span class="inferred0"><a name="line959"></a> 959     #     p response['content-type']
</span><span class="inferred1"><a name="line960"></a> 960     #
</span><span class="marked0"><a name="line961"></a> 961     def request_head(path, initheader = nil, &amp;block)
</span><span class="uncovered1"><a name="line962"></a> 962       request(Head.new(path, initheader), &amp;block)
</span><span class="uncovered0"><a name="line963"></a> 963     end
</span><span class="inferred1"><a name="line964"></a> 964 
</span><span class="inferred0"><a name="line965"></a> 965     # Sends a POST request to the +path+ and gets a response,
</span><span class="inferred1"><a name="line966"></a> 966     # as an HTTPResponse object.
</span><span class="inferred0"><a name="line967"></a> 967     # 
</span><span class="inferred1"><a name="line968"></a> 968     # When called with a block, yields an HTTPResponse object.
</span><span class="inferred0"><a name="line969"></a> 969     # The body of this response will not have been read yet;
</span><span class="inferred1"><a name="line970"></a> 970     # the caller can process it using HTTPResponse#read_body,
</span><span class="inferred0"><a name="line971"></a> 971     # if desired.
</span><span class="inferred1"><a name="line972"></a> 972     #
</span><span class="inferred0"><a name="line973"></a> 973     # Returns the response.
</span><span class="inferred1"><a name="line974"></a> 974     # 
</span><span class="inferred0"><a name="line975"></a> 975     # This method never raises Net::* exceptions.
</span><span class="inferred1"><a name="line976"></a> 976     # 
</span><span class="inferred0"><a name="line977"></a> 977     #     # example
</span><span class="inferred1"><a name="line978"></a> 978     #     response = http.request_post('/cgi-bin/nice.rb', 'datadatadata...')
</span><span class="inferred0"><a name="line979"></a> 979     #     p response.status
</span><span class="inferred1"><a name="line980"></a> 980     #     puts response.body          # body is already read
</span><span class="inferred0"><a name="line981"></a> 981     # 
</span><span class="inferred1"><a name="line982"></a> 982     #     # using block
</span><span class="inferred0"><a name="line983"></a> 983     #     http.request_post('/cgi-bin/nice.rb', 'datadatadata...') {|response|
</span><span class="inferred1"><a name="line984"></a> 984     #       p response.status
</span><span class="inferred0"><a name="line985"></a> 985     #       p response['content-type']
</span><span class="inferred1"><a name="line986"></a> 986     #       response.read_body do |str|   # read body now
</span><span class="inferred0"><a name="line987"></a> 987     #         print str
</span><span class="inferred1"><a name="line988"></a> 988     #       end
</span><span class="inferred0"><a name="line989"></a> 989     #     }
</span><span class="inferred1"><a name="line990"></a> 990     #
</span><span class="marked0"><a name="line991"></a> 991     def request_post(path, data, initheader = nil, &amp;block) # :yield: +response+
</span><span class="inferred1"><a name="line992"></a> 992       request Post.new(path, initheader), data, &amp;block
</span><span class="inferred0"><a name="line993"></a> 993     end
</span><span class="inferred1"><a name="line994"></a> 994 
</span><span class="marked0"><a name="line995"></a> 995     def request_put(path, data, initheader = nil, &amp;block)   #:nodoc:
</span><span class="uncovered1"><a name="line996"></a> 996       request Put.new(path, initheader), data, &amp;block
</span><span class="uncovered0"><a name="line997"></a> 997     end
</span><span class="inferred1"><a name="line998"></a> 998 
</span><span class="marked0"><a name="line999"></a> 999     alias get2   request_get    #:nodoc: obsolete
</span><span class="marked1"><a name="line1000"></a>1000     alias head2  request_head   #:nodoc: obsolete
</span><span class="marked0"><a name="line1001"></a>1001     alias post2  request_post   #:nodoc: obsolete
</span><span class="marked1"><a name="line1002"></a>1002     alias put2   request_put    #:nodoc: obsolete
</span><span class="inferred0"><a name="line1003"></a>1003 
</span><span class="inferred1"><a name="line1004"></a>1004 
</span><span class="inferred0"><a name="line1005"></a>1005     # Sends an HTTP request to the HTTP server.
</span><span class="inferred1"><a name="line1006"></a>1006     # This method also sends DATA string if DATA is given.
</span><span class="inferred0"><a name="line1007"></a>1007     #
</span><span class="inferred1"><a name="line1008"></a>1008     # Returns a HTTPResponse object.
</span><span class="inferred0"><a name="line1009"></a>1009     # 
</span><span class="inferred1"><a name="line1010"></a>1010     # This method never raises Net::* exceptions.
</span><span class="inferred0"><a name="line1011"></a>1011     #
</span><span class="inferred1"><a name="line1012"></a>1012     #    response = http.send_request('GET', '/index.html')
</span><span class="inferred0"><a name="line1013"></a>1013     #    puts response.body
</span><span class="inferred1"><a name="line1014"></a>1014     #
</span><span class="marked0"><a name="line1015"></a>1015     def send_request(name, path, data = nil, header = nil)
</span><span class="uncovered1"><a name="line1016"></a>1016       r = HTTPGenericRequest.new(name,(data ? true : false),true,path,header)
</span><span class="uncovered0"><a name="line1017"></a>1017       request r, data
</span><span class="uncovered1"><a name="line1018"></a>1018     end
</span><span class="inferred0"><a name="line1019"></a>1019 
</span><span class="inferred1"><a name="line1020"></a>1020     # Sends an HTTPRequest object REQUEST to the HTTP server.
</span><span class="inferred0"><a name="line1021"></a>1021     # This method also sends DATA string if REQUEST is a post/put request.
</span><span class="inferred1"><a name="line1022"></a>1022     # Giving DATA for get/head request causes ArgumentError.
</span><span class="inferred0"><a name="line1023"></a>1023     # 
</span><span class="inferred1"><a name="line1024"></a>1024     # When called with a block, yields an HTTPResponse object.
</span><span class="inferred0"><a name="line1025"></a>1025     # The body of this response will not have been read yet;
</span><span class="inferred1"><a name="line1026"></a>1026     # the caller can process it using HTTPResponse#read_body,
</span><span class="inferred0"><a name="line1027"></a>1027     # if desired.
</span><span class="inferred1"><a name="line1028"></a>1028     #
</span><span class="inferred0"><a name="line1029"></a>1029     # Returns a HTTPResponse object.
</span><span class="inferred1"><a name="line1030"></a>1030     # 
</span><span class="inferred0"><a name="line1031"></a>1031     # This method never raises Net::* exceptions.
</span><span class="inferred1"><a name="line1032"></a>1032     #
</span><span class="marked0"><a name="line1033"></a>1033     def request(req, body = nil, &amp;block)  # :yield: +response+
</span><span class="marked1"><a name="line1034"></a>1034       unless started?
</span><span class="marked0"><a name="line1035"></a>1035         start {
</span><span class="marked1"><a name="line1036"></a>1036           req['connection'] ||= 'close'
</span><span class="marked0"><a name="line1037"></a>1037           return request(req, body, &amp;block)
</span><span class="inferred1"><a name="line1038"></a>1038         }
</span><span class="inferred0"><a name="line1039"></a>1039       end
</span><span class="marked1"><a name="line1040"></a>1040       if proxy_user()
</span><span class="uncovered0"><a name="line1041"></a>1041         unless use_ssl?
</span><span class="uncovered1"><a name="line1042"></a>1042           req.proxy_basic_auth proxy_user(), proxy_pass()
</span><span class="uncovered0"><a name="line1043"></a>1043         end
</span><span class="uncovered1"><a name="line1044"></a>1044       end
</span><span class="inferred0"><a name="line1045"></a>1045 
</span><span class="marked1"><a name="line1046"></a>1046       req.set_body_internal body
</span><span class="marked0"><a name="line1047"></a>1047       begin_transport req
</span><span class="marked1"><a name="line1048"></a>1048         req.exec @socket, @curr_http_version, edit_path(req.path)
</span><span class="inferred0"><a name="line1049"></a>1049         begin
</span><span class="marked1"><a name="line1050"></a>1050           res = HTTPResponse.read_new(@socket)
</span><span class="marked0"><a name="line1051"></a>1051         end while res.kind_of?(HTTPContinue)
</span><span class="marked1"><a name="line1052"></a>1052         res.reading_body(@socket, req.response_body_permitted?) {
</span><span class="marked0"><a name="line1053"></a>1053           yield res if block_given?
</span><span class="inferred1"><a name="line1054"></a>1054         }
</span><span class="marked0"><a name="line1055"></a>1055       end_transport req, res
</span><span class="inferred1"><a name="line1056"></a>1056 
</span><span class="marked0"><a name="line1057"></a>1057       res
</span><span class="inferred1"><a name="line1058"></a>1058     end
</span><span class="inferred0"><a name="line1059"></a>1059 
</span><span class="marked1"><a name="line1060"></a>1060     private
</span><span class="inferred0"><a name="line1061"></a>1061 
</span><span class="marked1"><a name="line1062"></a>1062     def begin_transport(req)
</span><span class="marked0"><a name="line1063"></a>1063       if @socket.closed?
</span><span class="uncovered1"><a name="line1064"></a>1064         connect
</span><span class="uncovered0"><a name="line1065"></a>1065       end
</span><span class="marked1"><a name="line1066"></a>1066       if @seems_1_0_server
</span><span class="uncovered0"><a name="line1067"></a>1067         req['connection'] ||= 'close'
</span><span class="uncovered1"><a name="line1068"></a>1068       end
</span><span class="marked0"><a name="line1069"></a>1069       if not req.response_body_permitted? and @close_on_empty_response
</span><span class="uncovered1"><a name="line1070"></a>1070         req['connection'] ||= 'close'
</span><span class="uncovered0"><a name="line1071"></a>1071       end
</span><span class="marked1"><a name="line1072"></a>1072       req['host'] ||= addr_port()
</span><span class="inferred0"><a name="line1073"></a>1073     end
</span><span class="inferred1"><a name="line1074"></a>1074 
</span><span class="marked0"><a name="line1075"></a>1075     def end_transport(req, res)
</span><span class="marked1"><a name="line1076"></a>1076       @curr_http_version = res.http_version
</span><span class="marked0"><a name="line1077"></a>1077       if not res.body and @close_on_empty_response
</span><span class="uncovered1"><a name="line1078"></a>1078         D 'Conn close'
</span><span class="uncovered0"><a name="line1079"></a>1079         @socket.close
</span><span class="marked1"><a name="line1080"></a>1080       elsif keep_alive?(req, res)
</span><span class="uncovered0"><a name="line1081"></a>1081         D 'Conn keep-alive'
</span><span class="uncovered1"><a name="line1082"></a>1082         if @socket.closed?
</span><span class="uncovered0"><a name="line1083"></a>1083           D 'Conn (but seems 1.0 server)'
</span><span class="uncovered1"><a name="line1084"></a>1084           @seems_1_0_server = true
</span><span class="uncovered0"><a name="line1085"></a>1085         end
</span><span class="inferred1"><a name="line1086"></a>1086       else
</span><span class="marked0"><a name="line1087"></a>1087         D 'Conn close'
</span><span class="marked1"><a name="line1088"></a>1088         @socket.close
</span><span class="inferred0"><a name="line1089"></a>1089       end
</span><span class="inferred1"><a name="line1090"></a>1090     end
</span><span class="inferred0"><a name="line1091"></a>1091 
</span><span class="marked1"><a name="line1092"></a>1092     def keep_alive?(req, res)
</span><span class="marked0"><a name="line1093"></a>1093       return false if /close/i =~ req['connection'].to_s
</span><span class="uncovered1"><a name="line1094"></a>1094       return false if @seems_1_0_server
</span><span class="uncovered0"><a name="line1095"></a>1095       return true  if /keep-alive/i =~ res['connection'].to_s
</span><span class="uncovered1"><a name="line1096"></a>1096       return false if /close/i      =~ res['connection'].to_s
</span><span class="uncovered0"><a name="line1097"></a>1097       return true  if /keep-alive/i =~ res['proxy-connection'].to_s
</span><span class="uncovered1"><a name="line1098"></a>1098       return false if /close/i      =~ res['proxy-connection'].to_s
</span><span class="uncovered0"><a name="line1099"></a>1099       (@curr_http_version == '1.1')
</span><span class="uncovered1"><a name="line1100"></a>1100     end
</span><span class="inferred0"><a name="line1101"></a>1101 
</span><span class="inferred1"><a name="line1102"></a>1102     #
</span><span class="inferred0"><a name="line1103"></a>1103     # utils
</span><span class="inferred1"><a name="line1104"></a>1104     #
</span><span class="inferred0"><a name="line1105"></a>1105 
</span><span class="marked1"><a name="line1106"></a>1106     private
</span><span class="inferred0"><a name="line1107"></a>1107 
</span><span class="marked1"><a name="line1108"></a>1108     def addr_port
</span><span class="marked0"><a name="line1109"></a>1109       if use_ssl?
</span><span class="uncovered1"><a name="line1110"></a>1110         address() + (port == HTTP.https_default_port ? '' : &quot;:#{port()}&quot;)
</span><span class="inferred0"><a name="line1111"></a>1111       else
</span><span class="marked1"><a name="line1112"></a>1112         address() + (port == HTTP.http_default_port ? '' : &quot;:#{port()}&quot;)
</span><span class="inferred0"><a name="line1113"></a>1113       end
</span><span class="marked1"><a name="line1114"></a>1114     end
</span><span class="inferred0"><a name="line1115"></a>1115 
</span><span class="marked1"><a name="line1116"></a>1116     def D(msg)
</span><span class="marked0"><a name="line1117"></a>1117       return unless @debug_output
</span><span class="uncovered1"><a name="line1118"></a>1118       @debug_output &lt;&lt; msg
</span><span class="uncovered0"><a name="line1119"></a>1119       @debug_output &lt;&lt; &quot;\n&quot;
</span><span class="uncovered1"><a name="line1120"></a>1120     end
</span><span class="uncovered0"><a name="line1121"></a>1121 
</span><span class="uncovered1"><a name="line1122"></a>1122   end
</span><span class="inferred0"><a name="line1123"></a>1123 
</span><span class="marked1"><a name="line1124"></a>1124   HTTPSession = HTTP
</span><span class="inferred0"><a name="line1125"></a>1125 
</span><span class="inferred1"><a name="line1126"></a>1126 
</span><span class="inferred0"><a name="line1127"></a>1127   #
</span><span class="inferred1"><a name="line1128"></a>1128   # Header module.
</span><span class="inferred0"><a name="line1129"></a>1129   #
</span><span class="inferred1"><a name="line1130"></a>1130   # Provides access to @header in the mixed-into class as a hash-like
</span><span class="inferred0"><a name="line1131"></a>1131   # object, except with case-insensitive keys.  Also provides
</span><span class="inferred1"><a name="line1132"></a>1132   # methods for accessing commonly-used header values in a more
</span><span class="inferred0"><a name="line1133"></a>1133   # convenient format.
</span><span class="inferred1"><a name="line1134"></a>1134   #
</span><span class="marked0"><a name="line1135"></a>1135   module HTTPHeader
</span><span class="inferred1"><a name="line1136"></a>1136 
</span><span class="marked0"><a name="line1137"></a>1137     def initialize_http_header(initheader)
</span><span class="marked1"><a name="line1138"></a>1138       @header = {}
</span><span class="marked0"><a name="line1139"></a>1139       return unless initheader
</span><span class="marked1"><a name="line1140"></a>1140       initheader.each do |key, value|
</span><span class="marked0"><a name="line1141"></a>1141         warn &quot;net/http: warning: duplicated HTTP header: #{key}&quot; if key?(key) and $VERBOSE
</span><span class="marked1"><a name="line1142"></a>1142         @header[key.downcase] = [value.strip]
</span><span class="inferred0"><a name="line1143"></a>1143       end
</span><span class="inferred1"><a name="line1144"></a>1144     end
</span><span class="inferred0"><a name="line1145"></a>1145 
</span><span class="marked1"><a name="line1146"></a>1146     def size   #:nodoc: obsolete
</span><span class="uncovered0"><a name="line1147"></a>1147       @header.size
</span><span class="uncovered1"><a name="line1148"></a>1148     end
</span><span class="inferred0"><a name="line1149"></a>1149 
</span><span class="marked1"><a name="line1150"></a>1150     alias length size   #:nodoc: obsolete
</span><span class="inferred0"><a name="line1151"></a>1151 
</span><span class="inferred1"><a name="line1152"></a>1152     # Returns the header field corresponding to the case-insensitive key.
</span><span class="inferred0"><a name="line1153"></a>1153     # For example, a key of &quot;Content-Type&quot; might return &quot;text/html&quot;
</span><span class="marked1"><a name="line1154"></a>1154     def [](key)
</span><span class="marked0"><a name="line1155"></a>1155       a = @header[key.downcase] or return nil
</span><span class="marked1"><a name="line1156"></a>1156       a.join(', ')
</span><span class="inferred0"><a name="line1157"></a>1157     end
</span><span class="inferred1"><a name="line1158"></a>1158 
</span><span class="inferred0"><a name="line1159"></a>1159     # Sets the header field corresponding to the case-insensitive key.
</span><span class="marked1"><a name="line1160"></a>1160     def []=(key, val)
</span><span class="marked0"><a name="line1161"></a>1161       unless val
</span><span class="uncovered1"><a name="line1162"></a>1162         @header.delete key.downcase
</span><span class="uncovered0"><a name="line1163"></a>1163         return val
</span><span class="uncovered1"><a name="line1164"></a>1164       end
</span><span class="marked0"><a name="line1165"></a>1165       @header[key.downcase] = [val]
</span><span class="inferred1"><a name="line1166"></a>1166     end
</span><span class="inferred0"><a name="line1167"></a>1167 
</span><span class="inferred1"><a name="line1168"></a>1168     # [Ruby 1.8.3]
</span><span class="inferred0"><a name="line1169"></a>1169     # Adds header field instead of replace.
</span><span class="inferred1"><a name="line1170"></a>1170     # Second argument +val+ must be a String.
</span><span class="inferred0"><a name="line1171"></a>1171     # See also #[]=, #[] and #get_fields.
</span><span class="inferred1"><a name="line1172"></a>1172     #
</span><span class="inferred0"><a name="line1173"></a>1173     #   request.add_field 'X-My-Header', 'a'
</span><span class="inferred1"><a name="line1174"></a>1174     #   p request['X-My-Header']              #=&gt; &quot;a&quot;
</span><span class="inferred0"><a name="line1175"></a>1175     #   p request.get_fields('X-My-Header')   #=&gt; [&quot;a&quot;]
</span><span class="inferred1"><a name="line1176"></a>1176     #   request.add_field 'X-My-Header', 'b'
</span><span class="inferred0"><a name="line1177"></a>1177     #   p request['X-My-Header']              #=&gt; &quot;a, b&quot;
</span><span class="inferred1"><a name="line1178"></a>1178     #   p request.get_fields('X-My-Header')   #=&gt; [&quot;a&quot;, &quot;b&quot;]
</span><span class="inferred0"><a name="line1179"></a>1179     #   request.add_field 'X-My-Header', 'c'
</span><span class="inferred1"><a name="line1180"></a>1180     #   p request['X-My-Header']              #=&gt; &quot;a, b, c&quot;
</span><span class="inferred0"><a name="line1181"></a>1181     #   p request.get_fields('X-My-Header')   #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</span><span class="inferred1"><a name="line1182"></a>1182     #
</span><span class="marked0"><a name="line1183"></a>1183     def add_field(key, val)
</span><span class="marked1"><a name="line1184"></a>1184       if @header.key?(key.downcase)
</span><span class="uncovered0"><a name="line1185"></a>1185         @header[key.downcase].push val
</span><span class="inferred1"><a name="line1186"></a>1186       else
</span><span class="marked0"><a name="line1187"></a>1187         @header[key.downcase] = [val]
</span><span class="inferred1"><a name="line1188"></a>1188       end
</span><span class="marked0"><a name="line1189"></a>1189     end
</span><span class="inferred1"><a name="line1190"></a>1190 
</span><span class="inferred0"><a name="line1191"></a>1191     # [Ruby 1.8.3]
</span><span class="inferred1"><a name="line1192"></a>1192     # Returns an array of header field strings corresponding to the
</span><span class="inferred0"><a name="line1193"></a>1193     # case-insensitive +key+.  This method allows you to get duplicated
</span><span class="inferred1"><a name="line1194"></a>1194     # header fields without any processing.  See also #[].
</span><span class="inferred0"><a name="line1195"></a>1195     #
</span><span class="inferred1"><a name="line1196"></a>1196     #   p response.get_fields('Set-Cookie')
</span><span class="inferred0"><a name="line1197"></a>1197     #     #=&gt; [&quot;session=al98axx; expires=Fri, 31-Dec-1999 23:58:23&quot;,
</span><span class="inferred1"><a name="line1198"></a>1198     #          &quot;query=rubyscript; expires=Fri, 31-Dec-1999 23:58:23&quot;]
</span><span class="inferred0"><a name="line1199"></a>1199     #   p response['Set-Cookie']
</span><span class="inferred1"><a name="line1200"></a>1200     #     #=&gt; &quot;session=al98axx; expires=Fri, 31-Dec-1999 23:58:23, query=rubyscript; expires=Fri, 31-Dec-1999 23:58:23&quot;
</span><span class="inferred0"><a name="line1201"></a>1201     #
</span><span class="marked1"><a name="line1202"></a>1202     def get_fields(key)
</span><span class="uncovered0"><a name="line1203"></a>1203       return nil unless @header[key.downcase]
</span><span class="uncovered1"><a name="line1204"></a>1204       @header[key.downcase].dup
</span><span class="uncovered0"><a name="line1205"></a>1205     end
</span><span class="inferred1"><a name="line1206"></a>1206 
</span><span class="inferred0"><a name="line1207"></a>1207     # Returns the header field corresponding to the case-insensitive key.
</span><span class="inferred1"><a name="line1208"></a>1208     # Returns the default value +args+, or the result of the block, or nil,
</span><span class="inferred0"><a name="line1209"></a>1209     # if there's no header field named key.  See Hash#fetch
</span><span class="marked1"><a name="line1210"></a>1210     def fetch(key, *args, &amp;block)   #:yield: +key+
</span><span class="inferred0"><a name="line1211"></a>1211       a = @header.fetch(key.downcase, *args, &amp;block)
</span><span class="uncovered1"><a name="line1212"></a>1212       a.join(', ')
</span><span class="uncovered0"><a name="line1213"></a>1213     end
</span><span class="inferred1"><a name="line1214"></a>1214 
</span><span class="inferred0"><a name="line1215"></a>1215     # Iterates for each header names and values.
</span><span class="marked1"><a name="line1216"></a>1216     def each_header   #:yield: +key+, +value+
</span><span class="inferred0"><a name="line1217"></a>1217       @header.each do |k,va|
</span><span class="uncovered1"><a name="line1218"></a>1218         yield k, va.join(', ')
</span><span class="uncovered0"><a name="line1219"></a>1219       end
</span><span class="uncovered1"><a name="line1220"></a>1220     end
</span><span class="inferred0"><a name="line1221"></a>1221 
</span><span class="marked1"><a name="line1222"></a>1222     alias each each_header
</span><span class="inferred0"><a name="line1223"></a>1223 
</span><span class="inferred1"><a name="line1224"></a>1224     # Iterates for each header names.
</span><span class="marked0"><a name="line1225"></a>1225     def each_name(&amp;block)   #:yield: +key+
</span><span class="inferred1"><a name="line1226"></a>1226       @header.each_key(&amp;block)
</span><span class="inferred0"><a name="line1227"></a>1227     end
</span><span class="inferred1"><a name="line1228"></a>1228 
</span><span class="marked0"><a name="line1229"></a>1229     alias each_key each_name
</span><span class="inferred1"><a name="line1230"></a>1230 
</span><span class="inferred0"><a name="line1231"></a>1231     # Iterates for each capitalized header names.
</span><span class="marked1"><a name="line1232"></a>1232     def each_capitalized_name(&amp;block)   #:yield: +key+
</span><span class="inferred0"><a name="line1233"></a>1233       @header.each_key do |k|
</span><span class="uncovered1"><a name="line1234"></a>1234         yield capitalize(k)
</span><span class="uncovered0"><a name="line1235"></a>1235       end
</span><span class="uncovered1"><a name="line1236"></a>1236     end
</span><span class="inferred0"><a name="line1237"></a>1237 
</span><span class="inferred1"><a name="line1238"></a>1238     # Iterates for each header values.
</span><span class="marked0"><a name="line1239"></a>1239     def each_value   #:yield: +value+
</span><span class="inferred1"><a name="line1240"></a>1240       @header.each_value do |va|
</span><span class="uncovered0"><a name="line1241"></a>1241         yield va.join(', ')
</span><span class="uncovered1"><a name="line1242"></a>1242       end
</span><span class="uncovered0"><a name="line1243"></a>1243     end
</span><span class="inferred1"><a name="line1244"></a>1244 
</span><span class="inferred0"><a name="line1245"></a>1245     # Removes a header field.
</span><span class="marked1"><a name="line1246"></a>1246     def delete(key)
</span><span class="marked0"><a name="line1247"></a>1247       @header.delete(key.downcase)
</span><span class="marked1"><a name="line1248"></a>1248     end
</span><span class="inferred0"><a name="line1249"></a>1249 
</span><span class="inferred1"><a name="line1250"></a>1250     # true if +key+ header exists.
</span><span class="marked0"><a name="line1251"></a>1251     def key?(key)
</span><span class="marked1"><a name="line1252"></a>1252       @header.key?(key.downcase)
</span><span class="marked0"><a name="line1253"></a>1253     end
</span><span class="inferred1"><a name="line1254"></a>1254 
</span><span class="inferred0"><a name="line1255"></a>1255     # Returns a Hash consist of header names and values.
</span><span class="marked1"><a name="line1256"></a>1256     def to_hash
</span><span class="uncovered0"><a name="line1257"></a>1257       @header.dup
</span><span class="uncovered1"><a name="line1258"></a>1258     end
</span><span class="inferred0"><a name="line1259"></a>1259 
</span><span class="inferred1"><a name="line1260"></a>1260     # As for #each_header, except the keys are provided in capitalized form.
</span><span class="marked0"><a name="line1261"></a>1261     def each_capitalized
</span><span class="marked1"><a name="line1262"></a>1262       @header.each do |k,v|
</span><span class="marked0"><a name="line1263"></a>1263         yield capitalize(k), v.join(', ')
</span><span class="inferred1"><a name="line1264"></a>1264       end
</span><span class="marked0"><a name="line1265"></a>1265     end
</span><span class="inferred1"><a name="line1266"></a>1266 
</span><span class="marked0"><a name="line1267"></a>1267     alias canonical_each each_capitalized
</span><span class="inferred1"><a name="line1268"></a>1268 
</span><span class="marked0"><a name="line1269"></a>1269     def capitalize(name)
</span><span class="marked1"><a name="line1270"></a>1270       name.split(/-/).map {|s| s.capitalize }.join('-')
</span><span class="marked0"><a name="line1271"></a>1271     end
</span><span class="marked1"><a name="line1272"></a>1272     private :capitalize
</span><span class="inferred0"><a name="line1273"></a>1273 
</span><span class="inferred1"><a name="line1274"></a>1274     # Returns an Array of Range objects which represents Range: header field,
</span><span class="inferred0"><a name="line1275"></a>1275     # or +nil+ if there is no such header.
</span><span class="marked1"><a name="line1276"></a>1276     def range
</span><span class="uncovered0"><a name="line1277"></a>1277       return nil unless @header['range']
</span><span class="uncovered1"><a name="line1278"></a>1278       self['Range'].split(/,/).map {|spec|
</span><span class="uncovered0"><a name="line1279"></a>1279         m = /bytes\s*=\s*(\d+)?\s*-\s*(\d+)?/i.match(spec) or
</span><span class="uncovered1"><a name="line1280"></a>1280                 raise HTTPHeaderSyntaxError, &quot;wrong Range: #{spec}&quot;
</span><span class="uncovered0"><a name="line1281"></a>1281         d1 = m[1].to_i
</span><span class="uncovered1"><a name="line1282"></a>1282         d2 = m[2].to_i
</span><span class="uncovered0"><a name="line1283"></a>1283         if    m[1] and m[2] then  d1..d2
</span><span class="uncovered1"><a name="line1284"></a>1284         elsif m[1]          then  d1..-1
</span><span class="uncovered0"><a name="line1285"></a>1285         elsif          m[2] then -d2..-1
</span><span class="uncovered1"><a name="line1286"></a>1286         else
</span><span class="uncovered0"><a name="line1287"></a>1287           raise HTTPHeaderSyntaxError, 'range is not specified'
</span><span class="uncovered1"><a name="line1288"></a>1288         end
</span><span class="uncovered0"><a name="line1289"></a>1289       }
</span><span class="uncovered1"><a name="line1290"></a>1290     end
</span><span class="inferred0"><a name="line1291"></a>1291 
</span><span class="inferred1"><a name="line1292"></a>1292     # Set Range: header from Range (arg r) or beginning index and
</span><span class="inferred0"><a name="line1293"></a>1293     # length from it (arg idx&amp;len).
</span><span class="inferred1"><a name="line1294"></a>1294     #
</span><span class="inferred0"><a name="line1295"></a>1295     #   req.range = (0..1023)
</span><span class="inferred1"><a name="line1296"></a>1296     #   req.set_range 0, 1023
</span><span class="inferred0"><a name="line1297"></a>1297     #
</span><span class="marked1"><a name="line1298"></a>1298     def set_range(r, e = nil)
</span><span class="uncovered0"><a name="line1299"></a>1299       unless r
</span><span class="uncovered1"><a name="line1300"></a>1300         @header.delete 'range'
</span><span class="uncovered0"><a name="line1301"></a>1301         return r
</span><span class="uncovered1"><a name="line1302"></a>1302       end
</span><span class="uncovered0"><a name="line1303"></a>1303       r = (r...r+e) if e
</span><span class="uncovered1"><a name="line1304"></a>1304       case r
</span><span class="uncovered0"><a name="line1305"></a>1305       when Numeric
</span><span class="uncovered1"><a name="line1306"></a>1306         n = r.to_i
</span><span class="uncovered0"><a name="line1307"></a>1307         rangestr = (n &gt; 0 ? &quot;0-#{n-1}&quot; : &quot;-#{-n}&quot;)
</span><span class="uncovered1"><a name="line1308"></a>1308       when Range
</span><span class="uncovered0"><a name="line1309"></a>1309         first = r.first
</span><span class="uncovered1"><a name="line1310"></a>1310         last = r.last
</span><span class="uncovered0"><a name="line1311"></a>1311         last -= 1 if r.exclude_end?
</span><span class="uncovered1"><a name="line1312"></a>1312         if last == -1
</span><span class="uncovered0"><a name="line1313"></a>1313           rangestr = (first &gt; 0 ? &quot;#{first}-&quot; : &quot;-#{-first}&quot;)
</span><span class="uncovered1"><a name="line1314"></a>1314         else
</span><span class="uncovered0"><a name="line1315"></a>1315           raise HTTPHeaderSyntaxError, 'range.first is negative' if first &lt; 0
</span><span class="uncovered1"><a name="line1316"></a>1316           raise HTTPHeaderSyntaxError, 'range.last is negative' if last &lt; 0
</span><span class="uncovered0"><a name="line1317"></a>1317           raise HTTPHeaderSyntaxError, 'must be .first &lt; .last' if first &gt; last
</span><span class="uncovered1"><a name="line1318"></a>1318           rangestr = &quot;#{first}-#{last}&quot;
</span><span class="uncovered0"><a name="line1319"></a>1319         end
</span><span class="uncovered1"><a name="line1320"></a>1320       else
</span><span class="uncovered0"><a name="line1321"></a>1321         raise TypeError, 'Range/Integer is required'
</span><span class="uncovered1"><a name="line1322"></a>1322       end
</span><span class="uncovered0"><a name="line1323"></a>1323       @header['range'] = [&quot;bytes=#{rangestr}&quot;]
</span><span class="uncovered1"><a name="line1324"></a>1324       r
</span><span class="uncovered0"><a name="line1325"></a>1325     end
</span><span class="inferred1"><a name="line1326"></a>1326 
</span><span class="marked0"><a name="line1327"></a>1327     alias range= set_range
</span><span class="inferred1"><a name="line1328"></a>1328 
</span><span class="inferred0"><a name="line1329"></a>1329     # Returns an Integer object which represents the Content-Length: header field
</span><span class="inferred1"><a name="line1330"></a>1330     # or +nil+ if that field is not provided.
</span><span class="marked0"><a name="line1331"></a>1331     def content_length
</span><span class="marked1"><a name="line1332"></a>1332       return nil unless key?('Content-Length')
</span><span class="marked0"><a name="line1333"></a>1333       len = self['Content-Length'].slice(/\d+/) or
</span><span class="marked1"><a name="line1334"></a>1334           raise HTTPHeaderSyntaxError, 'wrong Content-Length format'
</span><span class="marked0"><a name="line1335"></a>1335       len.to_i
</span><span class="inferred1"><a name="line1336"></a>1336     end
</span><span class="inferred0"><a name="line1337"></a>1337     
</span><span class="marked1"><a name="line1338"></a>1338     def content_length=(len)
</span><span class="marked0"><a name="line1339"></a>1339       unless len
</span><span class="uncovered1"><a name="line1340"></a>1340         @header.delete 'content-length'
</span><span class="uncovered0"><a name="line1341"></a>1341         return nil
</span><span class="uncovered1"><a name="line1342"></a>1342       end
</span><span class="marked0"><a name="line1343"></a>1343       @header['content-length'] = [len.to_i.to_s]
</span><span class="inferred1"><a name="line1344"></a>1344     end
</span><span class="inferred0"><a name="line1345"></a>1345 
</span><span class="inferred1"><a name="line1346"></a>1346     # Returns &quot;true&quot; if the &quot;transfer-encoding&quot; header is present and
</span><span class="inferred0"><a name="line1347"></a>1347     # set to &quot;chunked&quot;.  This is an HTTP/1.1 feature, allowing the 
</span><span class="inferred1"><a name="line1348"></a>1348     # the content to be sent in &quot;chunks&quot; without at the outset
</span><span class="inferred0"><a name="line1349"></a>1349     # stating the entire content length.
</span><span class="marked1"><a name="line1350"></a>1350     def chunked?
</span><span class="marked0"><a name="line1351"></a>1351       return false unless @header['transfer-encoding']
</span><span class="uncovered1"><a name="line1352"></a>1352       field = self['Transfer-Encoding']
</span><span class="uncovered0"><a name="line1353"></a>1353       (/(?:\A|[^\-\w])chunked(?![\-\w])/i =~ field) ? true : false
</span><span class="uncovered1"><a name="line1354"></a>1354     end
</span><span class="inferred0"><a name="line1355"></a>1355 
</span><span class="inferred1"><a name="line1356"></a>1356     # Returns a Range object which represents Content-Range: header field.
</span><span class="inferred0"><a name="line1357"></a>1357     # This indicates, for a partial entity body, where this fragment
</span><span class="inferred1"><a name="line1358"></a>1358     # fits inside the full entity body, as range of byte offsets.
</span><span class="marked0"><a name="line1359"></a>1359     def content_range
</span><span class="uncovered1"><a name="line1360"></a>1360       return nil unless @header['content-range']
</span><span class="uncovered0"><a name="line1361"></a>1361       m = %r&lt;bytes\s+(\d+)-(\d+)/(\d+|\*)&gt;i.match(self['Content-Range']) or
</span><span class="uncovered1"><a name="line1362"></a>1362           raise HTTPHeaderSyntaxError, 'wrong Content-Range format'
</span><span class="uncovered0"><a name="line1363"></a>1363       m[1].to_i .. m[2].to_i + 1
</span><span class="uncovered1"><a name="line1364"></a>1364     end
</span><span class="inferred0"><a name="line1365"></a>1365 
</span><span class="inferred1"><a name="line1366"></a>1366     # The length of the range represented in Content-Range: header.
</span><span class="marked0"><a name="line1367"></a>1367     def range_length
</span><span class="uncovered1"><a name="line1368"></a>1368       r = content_range() or return nil
</span><span class="uncovered0"><a name="line1369"></a>1369       r.end - r.begin
</span><span class="uncovered1"><a name="line1370"></a>1370     end
</span><span class="inferred0"><a name="line1371"></a>1371 
</span><span class="inferred1"><a name="line1372"></a>1372     # Returns a content type string such as &quot;text/html&quot;.
</span><span class="inferred0"><a name="line1373"></a>1373     # This method returns nil if Content-Type: header field does not exist.
</span><span class="marked1"><a name="line1374"></a>1374     def content_type
</span><span class="marked0"><a name="line1375"></a>1375       return nil unless main_type()
</span><span class="marked1"><a name="line1376"></a>1376       if sub_type()
</span><span class="marked0"><a name="line1377"></a>1377       then &quot;#{main_type()}/#{sub_type()}&quot;
</span><span class="uncovered1"><a name="line1378"></a>1378       else main_type()
</span><span class="uncovered0"><a name="line1379"></a>1379       end
</span><span class="uncovered1"><a name="line1380"></a>1380     end
</span><span class="inferred0"><a name="line1381"></a>1381 
</span><span class="inferred1"><a name="line1382"></a>1382     # Returns a content type string such as &quot;text&quot;.
</span><span class="inferred0"><a name="line1383"></a>1383     # This method returns nil if Content-Type: header field does not exist.
</span><span class="marked1"><a name="line1384"></a>1384     def main_type
</span><span class="marked0"><a name="line1385"></a>1385       return nil unless @header['content-type']
</span><span class="marked1"><a name="line1386"></a>1386       self['Content-Type'].split(';').first.to_s.split('/')[0].to_s.strip
</span><span class="inferred0"><a name="line1387"></a>1387     end
</span><span class="inferred1"><a name="line1388"></a>1388     
</span><span class="inferred0"><a name="line1389"></a>1389     # Returns a content type string such as &quot;html&quot;.
</span><span class="inferred1"><a name="line1390"></a>1390     # This method returns nil if Content-Type: header field does not exist
</span><span class="inferred0"><a name="line1391"></a>1391     # or sub-type is not given (e.g. &quot;Content-Type: text&quot;).
</span><span class="marked1"><a name="line1392"></a>1392     def sub_type
</span><span class="marked0"><a name="line1393"></a>1393       return nil unless @header['content-type']
</span><span class="marked1"><a name="line1394"></a>1394       main, sub = *self['Content-Type'].split(';').first.to_s.split('/')
</span><span class="marked0"><a name="line1395"></a>1395       return nil unless sub
</span><span class="marked1"><a name="line1396"></a>1396       sub.strip
</span><span class="inferred0"><a name="line1397"></a>1397     end
</span><span class="inferred1"><a name="line1398"></a>1398 
</span><span class="inferred0"><a name="line1399"></a>1399     # Returns content type parameters as a Hash as like
</span><span class="inferred1"><a name="line1400"></a>1400     # {&quot;charset&quot; =&gt; &quot;iso-2022-jp&quot;}.
</span><span class="marked0"><a name="line1401"></a>1401     def type_params
</span><span class="uncovered1"><a name="line1402"></a>1402       result = {}
</span><span class="uncovered0"><a name="line1403"></a>1403       list = self['Content-Type'].to_s.split(';')
</span><span class="uncovered1"><a name="line1404"></a>1404       list.shift
</span><span class="uncovered0"><a name="line1405"></a>1405       list.each do |param|
</span><span class="uncovered1"><a name="line1406"></a>1406         k, v = *param.split('=', 2)
</span><span class="uncovered0"><a name="line1407"></a>1407         result[k.strip] = v.strip
</span><span class="uncovered1"><a name="line1408"></a>1408       end
</span><span class="uncovered0"><a name="line1409"></a>1409       result
</span><span class="uncovered1"><a name="line1410"></a>1410     end
</span><span class="inferred0"><a name="line1411"></a>1411 
</span><span class="inferred1"><a name="line1412"></a>1412     # Set Content-Type: header field by +type+ and +params+.
</span><span class="inferred0"><a name="line1413"></a>1413     # +type+ must be a String, +params+ must be a Hash.
</span><span class="marked1"><a name="line1414"></a>1414     def set_content_type(type, params = {})
</span><span class="uncovered0"><a name="line1415"></a>1415       @header['content-type'] = [type + params.map{|k,v|&quot;; #{k}=#{v}&quot;}.join('')]
</span><span class="uncovered1"><a name="line1416"></a>1416     end
</span><span class="inferred0"><a name="line1417"></a>1417 
</span><span class="marked1"><a name="line1418"></a>1418     alias content_type= set_content_type
</span><span class="inferred0"><a name="line1419"></a>1419 
</span><span class="inferred1"><a name="line1420"></a>1420     # Set header fields and a body from HTML form data.
</span><span class="inferred0"><a name="line1421"></a>1421     # +params+ should be a Hash containing HTML form data.
</span><span class="inferred1"><a name="line1422"></a>1422     # Optional argument +sep+ means data record separator.
</span><span class="inferred0"><a name="line1423"></a>1423     #
</span><span class="inferred1"><a name="line1424"></a>1424     # This method also set Content-Type: header field to
</span><span class="inferred0"><a name="line1425"></a>1425     # application/x-www-form-urlencoded.
</span><span class="marked1"><a name="line1426"></a>1426     def set_form_data(params, sep = '&amp;')
</span><span class="uncovered0"><a name="line1427"></a>1427       self.body = params.map {|k,v| &quot;#{urlencode(k.to_s)}=#{urlencode(v.to_s)}&quot; }.join(sep)
</span><span class="uncovered1"><a name="line1428"></a>1428       self.content_type = 'application/x-www-form-urlencoded'
</span><span class="uncovered0"><a name="line1429"></a>1429     end
</span><span class="inferred1"><a name="line1430"></a>1430 
</span><span class="marked0"><a name="line1431"></a>1431     alias form_data= set_form_data
</span><span class="inferred1"><a name="line1432"></a>1432 
</span><span class="marked0"><a name="line1433"></a>1433     def urlencode(str)
</span><span class="uncovered1"><a name="line1434"></a>1434       str.gsub(/[^a-zA-Z0-9_\.\-]/n) {|s| sprintf('%%%02x', s[0]) }
</span><span class="uncovered0"><a name="line1435"></a>1435     end
</span><span class="marked1"><a name="line1436"></a>1436     private :urlencode
</span><span class="inferred0"><a name="line1437"></a>1437 
</span><span class="inferred1"><a name="line1438"></a>1438     # Set the Authorization: header for &quot;Basic&quot; authorization.
</span><span class="marked0"><a name="line1439"></a>1439     def basic_auth(account, password)
</span><span class="marked1"><a name="line1440"></a>1440       @header['authorization'] = [basic_encode(account, password)]
</span><span class="marked0"><a name="line1441"></a>1441     end
</span><span class="inferred1"><a name="line1442"></a>1442 
</span><span class="inferred0"><a name="line1443"></a>1443     # Set Proxy-Authorization: header for &quot;Basic&quot; authorization.
</span><span class="marked1"><a name="line1444"></a>1444     def proxy_basic_auth(account, password)
</span><span class="uncovered0"><a name="line1445"></a>1445       @header['proxy-authorization'] = [basic_encode(account, password)]
</span><span class="uncovered1"><a name="line1446"></a>1446     end
</span><span class="inferred0"><a name="line1447"></a>1447 
</span><span class="marked1"><a name="line1448"></a>1448     def basic_encode(account, password)
</span><span class="marked0"><a name="line1449"></a>1449       'Basic ' + [&quot;#{account}:#{password}&quot;].pack('m').delete(&quot;\r\n&quot;)
</span><span class="marked1"><a name="line1450"></a>1450     end
</span><span class="marked0"><a name="line1451"></a>1451     private :basic_encode
</span><span class="inferred1"><a name="line1452"></a>1452 
</span><span class="inferred0"><a name="line1453"></a>1453   end
</span><span class="inferred1"><a name="line1454"></a>1454 
</span><span class="inferred0"><a name="line1455"></a>1455 
</span><span class="inferred1"><a name="line1456"></a>1456   #
</span><span class="inferred0"><a name="line1457"></a>1457   # Parent of HTTPRequest class.  Do not use this directly; use
</span><span class="inferred1"><a name="line1458"></a>1458   # a subclass of HTTPRequest.
</span><span class="inferred0"><a name="line1459"></a>1459   #
</span><span class="inferred1"><a name="line1460"></a>1460   # Mixes in the HTTPHeader module.
</span><span class="inferred0"><a name="line1461"></a>1461   #
</span><span class="marked1"><a name="line1462"></a>1462   class HTTPGenericRequest
</span><span class="inferred0"><a name="line1463"></a>1463 
</span><span class="marked1"><a name="line1464"></a>1464     include HTTPHeader
</span><span class="inferred0"><a name="line1465"></a>1465 
</span><span class="marked1"><a name="line1466"></a>1466     def initialize(m, reqbody, resbody, path, initheader = nil)
</span><span class="marked0"><a name="line1467"></a>1467       @method = m
</span><span class="marked1"><a name="line1468"></a>1468       @request_has_body = reqbody
</span><span class="marked0"><a name="line1469"></a>1469       @response_has_body = resbody
</span><span class="marked1"><a name="line1470"></a>1470       raise ArgumentError, &quot;HTTP request path is empty&quot; if path.empty?
</span><span class="marked0"><a name="line1471"></a>1471       @path = path
</span><span class="marked1"><a name="line1472"></a>1472       initialize_http_header initheader
</span><span class="marked0"><a name="line1473"></a>1473       self['Accept'] ||= '*/*'
</span><span class="marked1"><a name="line1474"></a>1474       @body = nil
</span><span class="marked0"><a name="line1475"></a>1475       @body_stream = nil
</span><span class="inferred1"><a name="line1476"></a>1476     end
</span><span class="inferred0"><a name="line1477"></a>1477 
</span><span class="marked1"><a name="line1478"></a>1478     attr_reader :method
</span><span class="marked0"><a name="line1479"></a>1479     attr_reader :path
</span><span class="inferred1"><a name="line1480"></a>1480 
</span><span class="marked0"><a name="line1481"></a>1481     def inspect
</span><span class="uncovered1"><a name="line1482"></a>1482       &quot;\#&lt;#{self.class} #{@method}&gt;&quot;
</span><span class="uncovered0"><a name="line1483"></a>1483     end
</span><span class="inferred1"><a name="line1484"></a>1484 
</span><span class="marked0"><a name="line1485"></a>1485     def request_body_permitted?
</span><span class="uncovered1"><a name="line1486"></a>1486       @request_has_body
</span><span class="uncovered0"><a name="line1487"></a>1487     end
</span><span class="inferred1"><a name="line1488"></a>1488 
</span><span class="marked0"><a name="line1489"></a>1489     def response_body_permitted?
</span><span class="marked1"><a name="line1490"></a>1490       @response_has_body
</span><span class="marked0"><a name="line1491"></a>1491     end
</span><span class="inferred1"><a name="line1492"></a>1492 
</span><span class="marked0"><a name="line1493"></a>1493     def body_exist?
</span><span class="uncovered1"><a name="line1494"></a>1494       warn &quot;Net::HTTPRequest#body_exist? is obsolete; use response_body_permitted?&quot; if $VERBOSE
</span><span class="uncovered0"><a name="line1495"></a>1495       response_body_permitted?
</span><span class="uncovered1"><a name="line1496"></a>1496     end
</span><span class="inferred0"><a name="line1497"></a>1497 
</span><span class="marked1"><a name="line1498"></a>1498     attr_reader :body
</span><span class="inferred0"><a name="line1499"></a>1499 
</span><span class="marked1"><a name="line1500"></a>1500     def body=(str)
</span><span class="marked0"><a name="line1501"></a>1501       @body = str
</span><span class="marked1"><a name="line1502"></a>1502       @body_stream = nil
</span><span class="marked0"><a name="line1503"></a>1503       str
</span><span class="inferred1"><a name="line1504"></a>1504     end
</span><span class="inferred0"><a name="line1505"></a>1505 
</span><span class="marked1"><a name="line1506"></a>1506     attr_reader :body_stream
</span><span class="inferred0"><a name="line1507"></a>1507 
</span><span class="marked1"><a name="line1508"></a>1508     def body_stream=(input)
</span><span class="uncovered0"><a name="line1509"></a>1509       @body = nil
</span><span class="uncovered1"><a name="line1510"></a>1510       @body_stream = input
</span><span class="uncovered0"><a name="line1511"></a>1511       input
</span><span class="uncovered1"><a name="line1512"></a>1512     end
</span><span class="inferred0"><a name="line1513"></a>1513 
</span><span class="marked1"><a name="line1514"></a>1514     def set_body_internal(str)   #:nodoc: internal use only
</span><span class="marked0"><a name="line1515"></a>1515       raise ArgumentError, &quot;both of body argument and HTTPRequest#body set&quot; if str and (@body or @body_stream)
</span><span class="marked1"><a name="line1516"></a>1516       self.body = str if str
</span><span class="inferred0"><a name="line1517"></a>1517     end
</span><span class="inferred1"><a name="line1518"></a>1518 
</span><span class="inferred0"><a name="line1519"></a>1519     #
</span><span class="inferred1"><a name="line1520"></a>1520     # write
</span><span class="inferred0"><a name="line1521"></a>1521     #
</span><span class="inferred1"><a name="line1522"></a>1522 
</span><span class="marked0"><a name="line1523"></a>1523     def exec(sock, ver, path)   #:nodoc: internal use only
</span><span class="marked1"><a name="line1524"></a>1524       if @body
</span><span class="marked0"><a name="line1525"></a>1525         send_request_with_body sock, ver, path, @body
</span><span class="marked1"><a name="line1526"></a>1526       elsif @body_stream
</span><span class="uncovered0"><a name="line1527"></a>1527         send_request_with_body_stream sock, ver, path, @body_stream
</span><span class="inferred1"><a name="line1528"></a>1528       else
</span><span class="marked0"><a name="line1529"></a>1529         write_header sock, ver, path
</span><span class="inferred1"><a name="line1530"></a>1530       end
</span><span class="marked0"><a name="line1531"></a>1531     end
</span><span class="inferred1"><a name="line1532"></a>1532 
</span><span class="marked0"><a name="line1533"></a>1533     private
</span><span class="inferred1"><a name="line1534"></a>1534 
</span><span class="marked0"><a name="line1535"></a>1535     def send_request_with_body(sock, ver, path, body)
</span><span class="marked1"><a name="line1536"></a>1536       self.content_length = body.length
</span><span class="marked0"><a name="line1537"></a>1537       delete 'Transfer-Encoding'
</span><span class="marked1"><a name="line1538"></a>1538       supply_default_content_type
</span><span class="marked0"><a name="line1539"></a>1539       write_header sock, ver, path
</span><span class="marked1"><a name="line1540"></a>1540       sock.write body
</span><span class="inferred0"><a name="line1541"></a>1541     end
</span><span class="inferred1"><a name="line1542"></a>1542 
</span><span class="marked0"><a name="line1543"></a>1543     def send_request_with_body_stream(sock, ver, path, f)
</span><span class="uncovered1"><a name="line1544"></a>1544       unless content_length() or chunked?
</span><span class="uncovered0"><a name="line1545"></a>1545         raise ArgumentError,
</span><span class="uncovered1"><a name="line1546"></a>1546             &quot;Content-Length not given and Transfer-Encoding is not `chunked'&quot;
</span><span class="uncovered0"><a name="line1547"></a>1547       end
</span><span class="uncovered1"><a name="line1548"></a>1548       supply_default_content_type
</span><span class="uncovered0"><a name="line1549"></a>1549       write_header sock, ver, path
</span><span class="uncovered1"><a name="line1550"></a>1550       if chunked?
</span><span class="uncovered0"><a name="line1551"></a>1551         while s = f.read(1024)
</span><span class="inferred1"><a name="line1552"></a>1552           sock.write(sprintf(&quot;%x\r\n&quot;, s.length) &lt;&lt; s &lt;&lt; &quot;\r\n&quot;)
</span><span class="inferred0"><a name="line1553"></a>1553         end
</span><span class="inferred1"><a name="line1554"></a>1554         sock.write &quot;0\r\n\r\n&quot;
</span><span class="inferred0"><a name="line1555"></a>1555       else
</span><span class="inferred1"><a name="line1556"></a>1556         while s = f.read(1024)
</span><span class="inferred0"><a name="line1557"></a>1557           sock.write s
</span><span class="inferred1"><a name="line1558"></a>1558         end
</span><span class="inferred0"><a name="line1559"></a>1559       end
</span><span class="inferred1"><a name="line1560"></a>1560     end
</span><span class="inferred0"><a name="line1561"></a>1561 
</span><span class="marked1"><a name="line1562"></a>1562     def supply_default_content_type
</span><span class="marked0"><a name="line1563"></a>1563       return if content_type()
</span><span class="inferred1"><a name="line1564"></a>1564       warn 'net/http: warning: Content-Type did not set; using application/x-www-form-urlencoded' if $VERBOSE
</span><span class="uncovered0"><a name="line1565"></a>1565       set_content_type 'application/x-www-form-urlencoded'
</span><span class="uncovered1"><a name="line1566"></a>1566     end
</span><span class="inferred0"><a name="line1567"></a>1567 
</span><span class="marked1"><a name="line1568"></a>1568     def write_header(sock, ver, path)
</span><span class="marked0"><a name="line1569"></a>1569       buf = &quot;#{@method} #{path} HTTP/#{ver}\r\n&quot;
</span><span class="marked1"><a name="line1570"></a>1570       each_capitalized do |k,v|
</span><span class="marked0"><a name="line1571"></a>1571         buf &lt;&lt; &quot;#{k}: #{v}\r\n&quot;
</span><span class="inferred1"><a name="line1572"></a>1572       end
</span><span class="marked0"><a name="line1573"></a>1573       buf &lt;&lt; &quot;\r\n&quot;
</span><span class="marked1"><a name="line1574"></a>1574       sock.write buf
</span><span class="inferred0"><a name="line1575"></a>1575     end
</span><span class="inferred1"><a name="line1576"></a>1576   
</span><span class="inferred0"><a name="line1577"></a>1577   end
</span><span class="inferred1"><a name="line1578"></a>1578 
</span><span class="inferred0"><a name="line1579"></a>1579 
</span><span class="inferred1"><a name="line1580"></a>1580   # 
</span><span class="inferred0"><a name="line1581"></a>1581   # HTTP request class. This class wraps request header and entity path.
</span><span class="inferred1"><a name="line1582"></a>1582   # You *must* use its subclass, Net::HTTP::Get, Post, Head.
</span><span class="inferred0"><a name="line1583"></a>1583   # 
</span><span class="marked1"><a name="line1584"></a>1584   class HTTPRequest &lt; HTTPGenericRequest
</span><span class="inferred0"><a name="line1585"></a>1585 
</span><span class="inferred1"><a name="line1586"></a>1586     # Creates HTTP request object.
</span><span class="marked0"><a name="line1587"></a>1587     def initialize(path, initheader = nil)
</span><span class="marked1"><a name="line1588"></a>1588       super self.class::METHOD,
</span><span class="inferred0"><a name="line1589"></a>1589             self.class::REQUEST_HAS_BODY,
</span><span class="inferred1"><a name="line1590"></a>1590             self.class::RESPONSE_HAS_BODY,
</span><span class="inferred0"><a name="line1591"></a>1591             path, initheader
</span><span class="marked1"><a name="line1592"></a>1592     end
</span><span class="inferred0"><a name="line1593"></a>1593   end
</span><span class="inferred1"><a name="line1594"></a>1594 
</span><span class="inferred0"><a name="line1595"></a>1595 
</span><span class="marked1"><a name="line1596"></a>1596   class HTTP   # reopen
</span><span class="inferred0"><a name="line1597"></a>1597     #
</span><span class="inferred1"><a name="line1598"></a>1598     # HTTP 1.1 methods --- RFC2616
</span><span class="inferred0"><a name="line1599"></a>1599     #
</span><span class="inferred1"><a name="line1600"></a>1600 
</span><span class="marked0"><a name="line1601"></a>1601     class Get &lt; HTTPRequest
</span><span class="marked1"><a name="line1602"></a>1602       METHOD = 'GET'
</span><span class="marked0"><a name="line1603"></a>1603       REQUEST_HAS_BODY  = false
</span><span class="marked1"><a name="line1604"></a>1604       RESPONSE_HAS_BODY = true
</span><span class="inferred0"><a name="line1605"></a>1605     end
</span><span class="inferred1"><a name="line1606"></a>1606 
</span><span class="marked0"><a name="line1607"></a>1607     class Head &lt; HTTPRequest
</span><span class="marked1"><a name="line1608"></a>1608       METHOD = 'HEAD'
</span><span class="marked0"><a name="line1609"></a>1609       REQUEST_HAS_BODY = false
</span><span class="marked1"><a name="line1610"></a>1610       RESPONSE_HAS_BODY = false
</span><span class="inferred0"><a name="line1611"></a>1611     end
</span><span class="inferred1"><a name="line1612"></a>1612 
</span><span class="marked0"><a name="line1613"></a>1613     class Post &lt; HTTPRequest
</span><span class="marked1"><a name="line1614"></a>1614       METHOD = 'POST'
</span><span class="marked0"><a name="line1615"></a>1615       REQUEST_HAS_BODY = true
</span><span class="marked1"><a name="line1616"></a>1616       RESPONSE_HAS_BODY = true
</span><span class="inferred0"><a name="line1617"></a>1617     end
</span><span class="inferred1"><a name="line1618"></a>1618 
</span><span class="marked0"><a name="line1619"></a>1619     class Put &lt; HTTPRequest
</span><span class="marked1"><a name="line1620"></a>1620       METHOD = 'PUT'
</span><span class="marked0"><a name="line1621"></a>1621       REQUEST_HAS_BODY = true
</span><span class="marked1"><a name="line1622"></a>1622       RESPONSE_HAS_BODY = true
</span><span class="inferred0"><a name="line1623"></a>1623     end
</span><span class="inferred1"><a name="line1624"></a>1624 
</span><span class="marked0"><a name="line1625"></a>1625     class Delete &lt; HTTPRequest
</span><span class="marked1"><a name="line1626"></a>1626       METHOD = 'DELETE'
</span><span class="marked0"><a name="line1627"></a>1627       REQUEST_HAS_BODY = false
</span><span class="marked1"><a name="line1628"></a>1628       RESPONSE_HAS_BODY = true
</span><span class="inferred0"><a name="line1629"></a>1629     end
</span><span class="inferred1"><a name="line1630"></a>1630 
</span><span class="marked0"><a name="line1631"></a>1631     class Options &lt; HTTPRequest
</span><span class="marked1"><a name="line1632"></a>1632       METHOD = 'OPTIONS'
</span><span class="marked0"><a name="line1633"></a>1633       REQUEST_HAS_BODY = false
</span><span class="marked1"><a name="line1634"></a>1634       RESPONSE_HAS_BODY = false
</span><span class="inferred0"><a name="line1635"></a>1635     end
</span><span class="inferred1"><a name="line1636"></a>1636 
</span><span class="marked0"><a name="line1637"></a>1637     class Trace &lt; HTTPRequest
</span><span class="marked1"><a name="line1638"></a>1638       METHOD = 'TRACE'
</span><span class="marked0"><a name="line1639"></a>1639       REQUEST_HAS_BODY = false
</span><span class="marked1"><a name="line1640"></a>1640       RESPONSE_HAS_BODY = true
</span><span class="inferred0"><a name="line1641"></a>1641     end
</span><span class="inferred1"><a name="line1642"></a>1642 
</span><span class="inferred0"><a name="line1643"></a>1643     #
</span><span class="inferred1"><a name="line1644"></a>1644     # WebDAV methods --- RFC2518
</span><span class="inferred0"><a name="line1645"></a>1645     #
</span><span class="inferred1"><a name="line1646"></a>1646 
</span><span class="marked0"><a name="line1647"></a>1647     class Propfind &lt; HTTPRequest
</span><span class="marked1"><a name="line1648"></a>1648       METHOD = 'PROPFIND'
</span><span class="marked0"><a name="line1649"></a>1649       REQUEST_HAS_BODY = true
</span><span class="marked1"><a name="line1650"></a>1650       RESPONSE_HAS_BODY = true
</span><span class="inferred0"><a name="line1651"></a>1651     end
</span><span class="inferred1"><a name="line1652"></a>1652 
</span><span class="marked0"><a name="line1653"></a>1653     class Proppatch &lt; HTTPRequest
</span><span class="marked1"><a name="line1654"></a>1654       METHOD = 'PROPPATCH'
</span><span class="marked0"><a name="line1655"></a>1655       REQUEST_HAS_BODY = true
</span><span class="marked1"><a name="line1656"></a>1656       RESPONSE_HAS_BODY = true
</span><span class="inferred0"><a name="line1657"></a>1657     end
</span><span class="inferred1"><a name="line1658"></a>1658 
</span><span class="marked0"><a name="line1659"></a>1659     class Mkcol &lt; HTTPRequest
</span><span class="marked1"><a name="line1660"></a>1660       METHOD = 'MKCOL'
</span><span class="marked0"><a name="line1661"></a>1661       REQUEST_HAS_BODY = true
</span><span class="marked1"><a name="line1662"></a>1662       RESPONSE_HAS_BODY = true
</span><span class="inferred0"><a name="line1663"></a>1663     end
</span><span class="inferred1"><a name="line1664"></a>1664 
</span><span class="marked0"><a name="line1665"></a>1665     class Copy &lt; HTTPRequest
</span><span class="marked1"><a name="line1666"></a>1666       METHOD = 'COPY'
</span><span class="marked0"><a name="line1667"></a>1667       REQUEST_HAS_BODY = false
</span><span class="marked1"><a name="line1668"></a>1668       RESPONSE_HAS_BODY = true
</span><span class="inferred0"><a name="line1669"></a>1669     end
</span><span class="inferred1"><a name="line1670"></a>1670 
</span><span class="marked0"><a name="line1671"></a>1671     class Move &lt; HTTPRequest
</span><span class="marked1"><a name="line1672"></a>1672       METHOD = 'MOVE'
</span><span class="marked0"><a name="line1673"></a>1673       REQUEST_HAS_BODY = false
</span><span class="marked1"><a name="line1674"></a>1674       RESPONSE_HAS_BODY = true
</span><span class="inferred0"><a name="line1675"></a>1675     end
</span><span class="inferred1"><a name="line1676"></a>1676 
</span><span class="marked0"><a name="line1677"></a>1677     class Lock &lt; HTTPRequest
</span><span class="marked1"><a name="line1678"></a>1678       METHOD = 'LOCK'
</span><span class="marked0"><a name="line1679"></a>1679       REQUEST_HAS_BODY = true
</span><span class="marked1"><a name="line1680"></a>1680       RESPONSE_HAS_BODY = true
</span><span class="inferred0"><a name="line1681"></a>1681     end
</span><span class="inferred1"><a name="line1682"></a>1682 
</span><span class="marked0"><a name="line1683"></a>1683     class Unlock &lt; HTTPRequest
</span><span class="marked1"><a name="line1684"></a>1684       METHOD = 'UNLOCK'
</span><span class="marked0"><a name="line1685"></a>1685       REQUEST_HAS_BODY = true
</span><span class="marked1"><a name="line1686"></a>1686       RESPONSE_HAS_BODY = true
</span><span class="inferred0"><a name="line1687"></a>1687     end
</span><span class="inferred1"><a name="line1688"></a>1688   end
</span><span class="inferred0"><a name="line1689"></a>1689 
</span><span class="inferred1"><a name="line1690"></a>1690 
</span><span class="inferred0"><a name="line1691"></a>1691   ###
</span><span class="inferred1"><a name="line1692"></a>1692   ### Response
</span><span class="inferred0"><a name="line1693"></a>1693   ###
</span><span class="inferred1"><a name="line1694"></a>1694 
</span><span class="inferred0"><a name="line1695"></a>1695   # HTTP exception class.
</span><span class="inferred1"><a name="line1696"></a>1696   # You must use its subclasses.
</span><span class="marked0"><a name="line1697"></a>1697   module HTTPExceptions
</span><span class="marked1"><a name="line1698"></a>1698     def initialize(msg, res)   #:nodoc:
</span><span class="uncovered0"><a name="line1699"></a>1699       super msg
</span><span class="uncovered1"><a name="line1700"></a>1700       @response = res
</span><span class="uncovered0"><a name="line1701"></a>1701     end
</span><span class="marked1"><a name="line1702"></a>1702     attr_reader :response
</span><span class="marked0"><a name="line1703"></a>1703     alias data response    #:nodoc: obsolete
</span><span class="inferred1"><a name="line1704"></a>1704   end
</span><span class="marked0"><a name="line1705"></a>1705   class HTTPError &lt; ProtocolError
</span><span class="marked1"><a name="line1706"></a>1706     include HTTPExceptions
</span><span class="inferred0"><a name="line1707"></a>1707   end
</span><span class="marked1"><a name="line1708"></a>1708   class HTTPRetriableError &lt; ProtoRetriableError
</span><span class="marked0"><a name="line1709"></a>1709     include HTTPExceptions
</span><span class="inferred1"><a name="line1710"></a>1710   end
</span><span class="marked0"><a name="line1711"></a>1711   class HTTPServerException &lt; ProtoServerError
</span><span class="inferred1"><a name="line1712"></a>1712     # We cannot use the name &quot;HTTPServerError&quot;, it is the name of the response.
</span><span class="marked0"><a name="line1713"></a>1713     include HTTPExceptions
</span><span class="inferred1"><a name="line1714"></a>1714   end
</span><span class="marked0"><a name="line1715"></a>1715   class HTTPFatalError &lt; ProtoFatalError
</span><span class="marked1"><a name="line1716"></a>1716     include HTTPExceptions
</span><span class="inferred0"><a name="line1717"></a>1717   end
</span><span class="inferred1"><a name="line1718"></a>1718 
</span><span class="inferred0"><a name="line1719"></a>1719 
</span><span class="inferred1"><a name="line1720"></a>1720   # HTTP response class. This class wraps response header and entity.
</span><span class="inferred0"><a name="line1721"></a>1721   # Mixes in the HTTPHeader module, which provides access to response
</span><span class="inferred1"><a name="line1722"></a>1722   # header values both via hash-like methods and individual readers.
</span><span class="inferred0"><a name="line1723"></a>1723   # Note that each possible HTTP response code defines its own 
</span><span class="inferred1"><a name="line1724"></a>1724   # HTTPResponse subclass.  These are listed below.
</span><span class="inferred0"><a name="line1725"></a>1725   # All classes are
</span><span class="inferred1"><a name="line1726"></a>1726   # defined under the Net module. Indentation indicates inheritance.
</span><span class="inferred0"><a name="line1727"></a>1727   # 
</span><span class="inferred1"><a name="line1728"></a>1728   #   xxx        HTTPResponse
</span><span class="inferred0"><a name="line1729"></a>1729   # 
</span><span class="inferred1"><a name="line1730"></a>1730   #     1xx        HTTPInformation
</span><span class="inferred0"><a name="line1731"></a>1731   #       100        HTTPContinue    
</span><span class="inferred1"><a name="line1732"></a>1732   #       101        HTTPSwitchProtocol
</span><span class="inferred0"><a name="line1733"></a>1733   # 
</span><span class="inferred1"><a name="line1734"></a>1734   #     2xx        HTTPSuccess
</span><span class="inferred0"><a name="line1735"></a>1735   #       200        HTTPOK
</span><span class="inferred1"><a name="line1736"></a>1736   #       201        HTTPCreated
</span><span class="inferred0"><a name="line1737"></a>1737   #       202        HTTPAccepted
</span><span class="inferred1"><a name="line1738"></a>1738   #       203        HTTPNonAuthoritativeInformation
</span><span class="inferred0"><a name="line1739"></a>1739   #       204        HTTPNoContent
</span><span class="inferred1"><a name="line1740"></a>1740   #       205        HTTPResetContent
</span><span class="inferred0"><a name="line1741"></a>1741   #       206        HTTPPartialContent
</span><span class="inferred1"><a name="line1742"></a>1742   # 
</span><span class="inferred0"><a name="line1743"></a>1743   #     3xx        HTTPRedirection
</span><span class="inferred1"><a name="line1744"></a>1744   #       300        HTTPMultipleChoice
</span><span class="inferred0"><a name="line1745"></a>1745   #       301        HTTPMovedPermanently
</span><span class="inferred1"><a name="line1746"></a>1746   #       302        HTTPFound
</span><span class="inferred0"><a name="line1747"></a>1747   #       303        HTTPSeeOther
</span><span class="inferred1"><a name="line1748"></a>1748   #       304        HTTPNotModified
</span><span class="inferred0"><a name="line1749"></a>1749   #       305        HTTPUseProxy
</span><span class="inferred1"><a name="line1750"></a>1750   #       307        HTTPTemporaryRedirect
</span><span class="inferred0"><a name="line1751"></a>1751   # 
</span><span class="inferred1"><a name="line1752"></a>1752   #     4xx        HTTPClientError
</span><span class="inferred0"><a name="line1753"></a>1753   #       400        HTTPBadRequest
</span><span class="inferred1"><a name="line1754"></a>1754   #       401        HTTPUnauthorized
</span><span class="inferred0"><a name="line1755"></a>1755   #       402        HTTPPaymentRequired
</span><span class="inferred1"><a name="line1756"></a>1756   #       403        HTTPForbidden
</span><span class="inferred0"><a name="line1757"></a>1757   #       404        HTTPNotFound
</span><span class="inferred1"><a name="line1758"></a>1758   #       405        HTTPMethodNotAllowed
</span><span class="inferred0"><a name="line1759"></a>1759   #       406        HTTPNotAcceptable
</span><span class="inferred1"><a name="line1760"></a>1760   #       407        HTTPProxyAuthenticationRequired
</span><span class="inferred0"><a name="line1761"></a>1761   #       408        HTTPRequestTimeOut
</span><span class="inferred1"><a name="line1762"></a>1762   #       409        HTTPConflict
</span><span class="inferred0"><a name="line1763"></a>1763   #       410        HTTPGone
</span><span class="inferred1"><a name="line1764"></a>1764   #       411        HTTPLengthRequired
</span><span class="inferred0"><a name="line1765"></a>1765   #       412        HTTPPreconditionFailed
</span><span class="inferred1"><a name="line1766"></a>1766   #       413        HTTPRequestEntityTooLarge
</span><span class="inferred0"><a name="line1767"></a>1767   #       414        HTTPRequestURITooLong
</span><span class="inferred1"><a name="line1768"></a>1768   #       415        HTTPUnsupportedMediaType
</span><span class="inferred0"><a name="line1769"></a>1769   #       416        HTTPRequestedRangeNotSatisfiable
</span><span class="inferred1"><a name="line1770"></a>1770   #       417        HTTPExpectationFailed
</span><span class="inferred0"><a name="line1771"></a>1771   # 
</span><span class="inferred1"><a name="line1772"></a>1772   #     5xx        HTTPServerError
</span><span class="inferred0"><a name="line1773"></a>1773   #       500        HTTPInternalServerError
</span><span class="inferred1"><a name="line1774"></a>1774   #       501        HTTPNotImplemented
</span><span class="inferred0"><a name="line1775"></a>1775   #       502        HTTPBadGateway
</span><span class="inferred1"><a name="line1776"></a>1776   #       503        HTTPServiceUnavailable
</span><span class="inferred0"><a name="line1777"></a>1777   #       504        HTTPGatewayTimeOut
</span><span class="inferred1"><a name="line1778"></a>1778   #       505        HTTPVersionNotSupported
</span><span class="inferred0"><a name="line1779"></a>1779   # 
</span><span class="inferred1"><a name="line1780"></a>1780   #     xxx        HTTPUnknownResponse
</span><span class="inferred0"><a name="line1781"></a>1781   #
</span><span class="marked1"><a name="line1782"></a>1782   class HTTPResponse
</span><span class="inferred0"><a name="line1783"></a>1783     # true if the response has body.
</span><span class="marked1"><a name="line1784"></a>1784     def HTTPResponse.body_permitted?
</span><span class="marked0"><a name="line1785"></a>1785       self::HAS_BODY
</span><span class="marked1"><a name="line1786"></a>1786     end
</span><span class="inferred0"><a name="line1787"></a>1787 
</span><span class="marked1"><a name="line1788"></a>1788     def HTTPResponse.exception_type   # :nodoc: internal use only
</span><span class="uncovered0"><a name="line1789"></a>1789       self::EXCEPTION_TYPE
</span><span class="uncovered1"><a name="line1790"></a>1790     end
</span><span class="uncovered0"><a name="line1791"></a>1791   end   # reopened after
</span><span class="inferred1"><a name="line1792"></a>1792 
</span><span class="inferred0"><a name="line1793"></a>1793   # :stopdoc:
</span><span class="inferred1"><a name="line1794"></a>1794 
</span><span class="marked0"><a name="line1795"></a>1795   class HTTPUnknownResponse &lt; HTTPResponse
</span><span class="marked1"><a name="line1796"></a>1796     HAS_BODY = true
</span><span class="marked0"><a name="line1797"></a>1797     EXCEPTION_TYPE = HTTPError
</span><span class="inferred1"><a name="line1798"></a>1798   end
</span><span class="marked0"><a name="line1799"></a>1799   class HTTPInformation &lt; HTTPResponse           # 1xx
</span><span class="marked1"><a name="line1800"></a>1800     HAS_BODY = false
</span><span class="marked0"><a name="line1801"></a>1801     EXCEPTION_TYPE = HTTPError
</span><span class="inferred1"><a name="line1802"></a>1802   end
</span><span class="marked0"><a name="line1803"></a>1803   class HTTPSuccess &lt; HTTPResponse               # 2xx
</span><span class="marked1"><a name="line1804"></a>1804     HAS_BODY = true
</span><span class="marked0"><a name="line1805"></a>1805     EXCEPTION_TYPE = HTTPError
</span><span class="inferred1"><a name="line1806"></a>1806   end
</span><span class="marked0"><a name="line1807"></a>1807   class HTTPRedirection &lt; HTTPResponse           # 3xx
</span><span class="marked1"><a name="line1808"></a>1808     HAS_BODY = true
</span><span class="marked0"><a name="line1809"></a>1809     EXCEPTION_TYPE = HTTPRetriableError
</span><span class="inferred1"><a name="line1810"></a>1810   end
</span><span class="marked0"><a name="line1811"></a>1811   class HTTPClientError &lt; HTTPResponse           # 4xx
</span><span class="marked1"><a name="line1812"></a>1812     HAS_BODY = true
</span><span class="marked0"><a name="line1813"></a>1813     EXCEPTION_TYPE = HTTPServerException   # for backward compatibility
</span><span class="inferred1"><a name="line1814"></a>1814   end
</span><span class="marked0"><a name="line1815"></a>1815   class HTTPServerError &lt; HTTPResponse           # 5xx
</span><span class="marked1"><a name="line1816"></a>1816     HAS_BODY = true
</span><span class="marked0"><a name="line1817"></a>1817     EXCEPTION_TYPE = HTTPFatalError    # for backward compatibility
</span><span class="inferred1"><a name="line1818"></a>1818   end
</span><span class="inferred0"><a name="line1819"></a>1819 
</span><span class="marked1"><a name="line1820"></a>1820   class HTTPContinue &lt; HTTPInformation           # 100
</span><span class="marked0"><a name="line1821"></a>1821     HAS_BODY = false
</span><span class="inferred1"><a name="line1822"></a>1822   end
</span><span class="marked0"><a name="line1823"></a>1823   class HTTPSwitchProtocol &lt; HTTPInformation     # 101
</span><span class="marked1"><a name="line1824"></a>1824     HAS_BODY = false
</span><span class="inferred0"><a name="line1825"></a>1825   end
</span><span class="inferred1"><a name="line1826"></a>1826 
</span><span class="marked0"><a name="line1827"></a>1827   class HTTPOK &lt; HTTPSuccess                            # 200
</span><span class="marked1"><a name="line1828"></a>1828     HAS_BODY = true
</span><span class="inferred0"><a name="line1829"></a>1829   end
</span><span class="marked1"><a name="line1830"></a>1830   class HTTPCreated &lt; HTTPSuccess                       # 201
</span><span class="marked0"><a name="line1831"></a>1831     HAS_BODY = true
</span><span class="inferred1"><a name="line1832"></a>1832   end
</span><span class="marked0"><a name="line1833"></a>1833   class HTTPAccepted &lt; HTTPSuccess                      # 202
</span><span class="marked1"><a name="line1834"></a>1834     HAS_BODY = true
</span><span class="inferred0"><a name="line1835"></a>1835   end
</span><span class="marked1"><a name="line1836"></a>1836   class HTTPNonAuthoritativeInformation &lt; HTTPSuccess   # 203
</span><span class="marked0"><a name="line1837"></a>1837     HAS_BODY = true
</span><span class="inferred1"><a name="line1838"></a>1838   end
</span><span class="marked0"><a name="line1839"></a>1839   class HTTPNoContent &lt; HTTPSuccess                     # 204
</span><span class="marked1"><a name="line1840"></a>1840     HAS_BODY = false
</span><span class="inferred0"><a name="line1841"></a>1841   end
</span><span class="marked1"><a name="line1842"></a>1842   class HTTPResetContent &lt; HTTPSuccess                  # 205
</span><span class="marked0"><a name="line1843"></a>1843     HAS_BODY = false
</span><span class="inferred1"><a name="line1844"></a>1844   end
</span><span class="marked0"><a name="line1845"></a>1845   class HTTPPartialContent &lt; HTTPSuccess                # 206
</span><span class="marked1"><a name="line1846"></a>1846     HAS_BODY = true
</span><span class="inferred0"><a name="line1847"></a>1847   end
</span><span class="inferred1"><a name="line1848"></a>1848 
</span><span class="marked0"><a name="line1849"></a>1849   class HTTPMultipleChoice &lt; HTTPRedirection     # 300
</span><span class="marked1"><a name="line1850"></a>1850     HAS_BODY = true
</span><span class="inferred0"><a name="line1851"></a>1851   end
</span><span class="marked1"><a name="line1852"></a>1852   class HTTPMovedPermanently &lt; HTTPRedirection   # 301
</span><span class="marked0"><a name="line1853"></a>1853     HAS_BODY = true
</span><span class="inferred1"><a name="line1854"></a>1854   end
</span><span class="marked0"><a name="line1855"></a>1855   class HTTPFound &lt; HTTPRedirection              # 302
</span><span class="marked1"><a name="line1856"></a>1856     HAS_BODY = true
</span><span class="inferred0"><a name="line1857"></a>1857   end
</span><span class="marked1"><a name="line1858"></a>1858   HTTPMovedTemporarily = HTTPFound
</span><span class="marked0"><a name="line1859"></a>1859   class HTTPSeeOther &lt; HTTPRedirection           # 303
</span><span class="marked1"><a name="line1860"></a>1860     HAS_BODY = true
</span><span class="inferred0"><a name="line1861"></a>1861   end
</span><span class="marked1"><a name="line1862"></a>1862   class HTTPNotModified &lt; HTTPRedirection        # 304
</span><span class="marked0"><a name="line1863"></a>1863     HAS_BODY = false
</span><span class="inferred1"><a name="line1864"></a>1864   end
</span><span class="marked0"><a name="line1865"></a>1865   class HTTPUseProxy &lt; HTTPRedirection           # 305
</span><span class="marked1"><a name="line1866"></a>1866     HAS_BODY = false
</span><span class="inferred0"><a name="line1867"></a>1867   end
</span><span class="inferred1"><a name="line1868"></a>1868   # 306 unused
</span><span class="marked0"><a name="line1869"></a>1869   class HTTPTemporaryRedirect &lt; HTTPRedirection  # 307
</span><span class="marked1"><a name="line1870"></a>1870     HAS_BODY = true
</span><span class="inferred0"><a name="line1871"></a>1871   end
</span><span class="inferred1"><a name="line1872"></a>1872 
</span><span class="marked0"><a name="line1873"></a>1873   class HTTPBadRequest &lt; HTTPClientError                    # 400
</span><span class="marked1"><a name="line1874"></a>1874     HAS_BODY = true
</span><span class="inferred0"><a name="line1875"></a>1875   end
</span><span class="marked1"><a name="line1876"></a>1876   class HTTPUnauthorized &lt; HTTPClientError                  # 401
</span><span class="marked0"><a name="line1877"></a>1877     HAS_BODY = true
</span><span class="inferred1"><a name="line1878"></a>1878   end
</span><span class="marked0"><a name="line1879"></a>1879   class HTTPPaymentRequired &lt; HTTPClientError               # 402
</span><span class="marked1"><a name="line1880"></a>1880     HAS_BODY = true
</span><span class="inferred0"><a name="line1881"></a>1881   end
</span><span class="marked1"><a name="line1882"></a>1882   class HTTPForbidden &lt; HTTPClientError                     # 403
</span><span class="marked0"><a name="line1883"></a>1883     HAS_BODY = true
</span><span class="inferred1"><a name="line1884"></a>1884   end
</span><span class="marked0"><a name="line1885"></a>1885   class HTTPNotFound &lt; HTTPClientError                      # 404
</span><span class="marked1"><a name="line1886"></a>1886     HAS_BODY = true
</span><span class="inferred0"><a name="line1887"></a>1887   end
</span><span class="marked1"><a name="line1888"></a>1888   class HTTPMethodNotAllowed &lt; HTTPClientError              # 405
</span><span class="marked0"><a name="line1889"></a>1889     HAS_BODY = true
</span><span class="inferred1"><a name="line1890"></a>1890   end
</span><span class="marked0"><a name="line1891"></a>1891   class HTTPNotAcceptable &lt; HTTPClientError                 # 406
</span><span class="marked1"><a name="line1892"></a>1892     HAS_BODY = true
</span><span class="inferred0"><a name="line1893"></a>1893   end
</span><span class="marked1"><a name="line1894"></a>1894   class HTTPProxyAuthenticationRequired &lt; HTTPClientError   # 407
</span><span class="marked0"><a name="line1895"></a>1895     HAS_BODY = true
</span><span class="inferred1"><a name="line1896"></a>1896   end
</span><span class="marked0"><a name="line1897"></a>1897   class HTTPRequestTimeOut &lt; HTTPClientError                # 408
</span><span class="marked1"><a name="line1898"></a>1898     HAS_BODY = true
</span><span class="inferred0"><a name="line1899"></a>1899   end
</span><span class="marked1"><a name="line1900"></a>1900   class HTTPConflict &lt; HTTPClientError                      # 409
</span><span class="marked0"><a name="line1901"></a>1901     HAS_BODY = true
</span><span class="inferred1"><a name="line1902"></a>1902   end
</span><span class="marked0"><a name="line1903"></a>1903   class HTTPGone &lt; HTTPClientError                          # 410
</span><span class="marked1"><a name="line1904"></a>1904     HAS_BODY = true
</span><span class="inferred0"><a name="line1905"></a>1905   end
</span><span class="marked1"><a name="line1906"></a>1906   class HTTPLengthRequired &lt; HTTPClientError                # 411
</span><span class="marked0"><a name="line1907"></a>1907     HAS_BODY = true
</span><span class="inferred1"><a name="line1908"></a>1908   end
</span><span class="marked0"><a name="line1909"></a>1909   class HTTPPreconditionFailed &lt; HTTPClientError            # 412
</span><span class="marked1"><a name="line1910"></a>1910     HAS_BODY = true
</span><span class="inferred0"><a name="line1911"></a>1911   end
</span><span class="marked1"><a name="line1912"></a>1912   class HTTPRequestEntityTooLarge &lt; HTTPClientError         # 413
</span><span class="marked0"><a name="line1913"></a>1913     HAS_BODY = true
</span><span class="inferred1"><a name="line1914"></a>1914   end
</span><span class="marked0"><a name="line1915"></a>1915   class HTTPRequestURITooLong &lt; HTTPClientError             # 414
</span><span class="marked1"><a name="line1916"></a>1916     HAS_BODY = true
</span><span class="inferred0"><a name="line1917"></a>1917   end
</span><span class="marked1"><a name="line1918"></a>1918   HTTPRequestURITooLarge = HTTPRequestURITooLong
</span><span class="marked0"><a name="line1919"></a>1919   class HTTPUnsupportedMediaType &lt; HTTPClientError          # 415
</span><span class="marked1"><a name="line1920"></a>1920     HAS_BODY = true
</span><span class="inferred0"><a name="line1921"></a>1921   end
</span><span class="marked1"><a name="line1922"></a>1922   class HTTPRequestedRangeNotSatisfiable &lt; HTTPClientError  # 416
</span><span class="marked0"><a name="line1923"></a>1923     HAS_BODY = true
</span><span class="inferred1"><a name="line1924"></a>1924   end
</span><span class="marked0"><a name="line1925"></a>1925   class HTTPExpectationFailed &lt; HTTPClientError             # 417
</span><span class="marked1"><a name="line1926"></a>1926     HAS_BODY = true
</span><span class="inferred0"><a name="line1927"></a>1927   end
</span><span class="inferred1"><a name="line1928"></a>1928 
</span><span class="marked0"><a name="line1929"></a>1929   class HTTPInternalServerError &lt; HTTPServerError   # 500
</span><span class="marked1"><a name="line1930"></a>1930     HAS_BODY = true
</span><span class="inferred0"><a name="line1931"></a>1931   end
</span><span class="marked1"><a name="line1932"></a>1932   class HTTPNotImplemented &lt; HTTPServerError        # 501
</span><span class="marked0"><a name="line1933"></a>1933     HAS_BODY = true
</span><span class="inferred1"><a name="line1934"></a>1934   end
</span><span class="marked0"><a name="line1935"></a>1935   class HTTPBadGateway &lt; HTTPServerError            # 502
</span><span class="marked1"><a name="line1936"></a>1936     HAS_BODY = true
</span><span class="inferred0"><a name="line1937"></a>1937   end
</span><span class="marked1"><a name="line1938"></a>1938   class HTTPServiceUnavailable &lt; HTTPServerError    # 503
</span><span class="marked0"><a name="line1939"></a>1939     HAS_BODY = true
</span><span class="inferred1"><a name="line1940"></a>1940   end
</span><span class="marked0"><a name="line1941"></a>1941   class HTTPGatewayTimeOut &lt; HTTPServerError        # 504
</span><span class="marked1"><a name="line1942"></a>1942     HAS_BODY = true
</span><span class="inferred0"><a name="line1943"></a>1943   end
</span><span class="marked1"><a name="line1944"></a>1944   class HTTPVersionNotSupported &lt; HTTPServerError   # 505
</span><span class="marked0"><a name="line1945"></a>1945     HAS_BODY = true
</span><span class="inferred1"><a name="line1946"></a>1946   end
</span><span class="inferred0"><a name="line1947"></a>1947 
</span><span class="inferred1"><a name="line1948"></a>1948   # :startdoc:
</span><span class="inferred0"><a name="line1949"></a>1949 
</span><span class="inferred1"><a name="line1950"></a>1950 
</span><span class="marked0"><a name="line1951"></a>1951   class HTTPResponse   # reopen
</span><span class="inferred1"><a name="line1952"></a>1952 
</span><span class="marked0"><a name="line1953"></a>1953     CODE_CLASS_TO_OBJ = {
</span><span class="inferred1"><a name="line1954"></a>1954       '1' =&gt; HTTPInformation,
</span><span class="inferred0"><a name="line1955"></a>1955       '2' =&gt; HTTPSuccess,
</span><span class="inferred1"><a name="line1956"></a>1956       '3' =&gt; HTTPRedirection,
</span><span class="inferred0"><a name="line1957"></a>1957       '4' =&gt; HTTPClientError,
</span><span class="inferred1"><a name="line1958"></a>1958       '5' =&gt; HTTPServerError
</span><span class="inferred0"><a name="line1959"></a>1959     }
</span><span class="marked1"><a name="line1960"></a>1960     CODE_TO_OBJ = {
</span><span class="inferred0"><a name="line1961"></a>1961       '100' =&gt; HTTPContinue,
</span><span class="inferred1"><a name="line1962"></a>1962       '101' =&gt; HTTPSwitchProtocol,
</span><span class="inferred0"><a name="line1963"></a>1963 
</span><span class="inferred1"><a name="line1964"></a>1964       '200' =&gt; HTTPOK,
</span><span class="inferred0"><a name="line1965"></a>1965       '201' =&gt; HTTPCreated,
</span><span class="inferred1"><a name="line1966"></a>1966       '202' =&gt; HTTPAccepted,
</span><span class="inferred0"><a name="line1967"></a>1967       '203' =&gt; HTTPNonAuthoritativeInformation,
</span><span class="inferred1"><a name="line1968"></a>1968       '204' =&gt; HTTPNoContent,
</span><span class="inferred0"><a name="line1969"></a>1969       '205' =&gt; HTTPResetContent,
</span><span class="inferred1"><a name="line1970"></a>1970       '206' =&gt; HTTPPartialContent,
</span><span class="inferred0"><a name="line1971"></a>1971 
</span><span class="inferred1"><a name="line1972"></a>1972       '300' =&gt; HTTPMultipleChoice,
</span><span class="inferred0"><a name="line1973"></a>1973       '301' =&gt; HTTPMovedPermanently,
</span><span class="inferred1"><a name="line1974"></a>1974       '302' =&gt; HTTPFound,
</span><span class="inferred0"><a name="line1975"></a>1975       '303' =&gt; HTTPSeeOther,
</span><span class="inferred1"><a name="line1976"></a>1976       '304' =&gt; HTTPNotModified,
</span><span class="inferred0"><a name="line1977"></a>1977       '305' =&gt; HTTPUseProxy,
</span><span class="inferred1"><a name="line1978"></a>1978       '307' =&gt; HTTPTemporaryRedirect,
</span><span class="inferred0"><a name="line1979"></a>1979 
</span><span class="inferred1"><a name="line1980"></a>1980       '400' =&gt; HTTPBadRequest,
</span><span class="inferred0"><a name="line1981"></a>1981       '401' =&gt; HTTPUnauthorized,
</span><span class="inferred1"><a name="line1982"></a>1982       '402' =&gt; HTTPPaymentRequired,
</span><span class="inferred0"><a name="line1983"></a>1983       '403' =&gt; HTTPForbidden,
</span><span class="inferred1"><a name="line1984"></a>1984       '404' =&gt; HTTPNotFound,
</span><span class="inferred0"><a name="line1985"></a>1985       '405' =&gt; HTTPMethodNotAllowed,
</span><span class="inferred1"><a name="line1986"></a>1986       '406' =&gt; HTTPNotAcceptable,
</span><span class="inferred0"><a name="line1987"></a>1987       '407' =&gt; HTTPProxyAuthenticationRequired,
</span><span class="inferred1"><a name="line1988"></a>1988       '408' =&gt; HTTPRequestTimeOut,
</span><span class="inferred0"><a name="line1989"></a>1989       '409' =&gt; HTTPConflict,
</span><span class="inferred1"><a name="line1990"></a>1990       '410' =&gt; HTTPGone,
</span><span class="inferred0"><a name="line1991"></a>1991       '411' =&gt; HTTPLengthRequired,
</span><span class="inferred1"><a name="line1992"></a>1992       '412' =&gt; HTTPPreconditionFailed,
</span><span class="inferred0"><a name="line1993"></a>1993       '413' =&gt; HTTPRequestEntityTooLarge,
</span><span class="inferred1"><a name="line1994"></a>1994       '414' =&gt; HTTPRequestURITooLong,
</span><span class="inferred0"><a name="line1995"></a>1995       '415' =&gt; HTTPUnsupportedMediaType,
</span><span class="inferred1"><a name="line1996"></a>1996       '416' =&gt; HTTPRequestedRangeNotSatisfiable,
</span><span class="inferred0"><a name="line1997"></a>1997       '417' =&gt; HTTPExpectationFailed,
</span><span class="inferred1"><a name="line1998"></a>1998 
</span><span class="inferred0"><a name="line1999"></a>1999       '500' =&gt; HTTPInternalServerError,
</span><span class="inferred1"><a name="line2000"></a>2000       '501' =&gt; HTTPNotImplemented,
</span><span class="inferred0"><a name="line2001"></a>2001       '502' =&gt; HTTPBadGateway,
</span><span class="inferred1"><a name="line2002"></a>2002       '503' =&gt; HTTPServiceUnavailable,
</span><span class="inferred0"><a name="line2003"></a>2003       '504' =&gt; HTTPGatewayTimeOut,
</span><span class="inferred1"><a name="line2004"></a>2004       '505' =&gt; HTTPVersionNotSupported
</span><span class="inferred0"><a name="line2005"></a>2005     }
</span><span class="inferred1"><a name="line2006"></a>2006 
</span><span class="marked0"><a name="line2007"></a>2007     class &lt;&lt; HTTPResponse
</span><span class="marked1"><a name="line2008"></a>2008       def read_new(sock)   #:nodoc: internal use only
</span><span class="marked0"><a name="line2009"></a>2009         httpv, code, msg = read_status_line(sock)
</span><span class="marked1"><a name="line2010"></a>2010         res = response_class(code).new(httpv, code, msg)
</span><span class="marked0"><a name="line2011"></a>2011         each_response_header(sock) do |k,v|
</span><span class="marked1"><a name="line2012"></a>2012           res.add_field k, v
</span><span class="inferred0"><a name="line2013"></a>2013         end
</span><span class="marked1"><a name="line2014"></a>2014         res
</span><span class="inferred0"><a name="line2015"></a>2015       end
</span><span class="inferred1"><a name="line2016"></a>2016 
</span><span class="marked0"><a name="line2017"></a>2017       private
</span><span class="inferred1"><a name="line2018"></a>2018 
</span><span class="marked0"><a name="line2019"></a>2019       def read_status_line(sock)
</span><span class="marked1"><a name="line2020"></a>2020         str = sock.readline
</span><span class="inferred0"><a name="line2021"></a>2021         m = /\AHTTP(?:\/(\d+\.\d+))?\s+(\d\d\d)\s*(.*)\z/in.match(str) or
</span><span class="marked1"><a name="line2022"></a>2022           raise HTTPBadResponse, &quot;wrong status line: #{str.dump}&quot;
</span><span class="marked0"><a name="line2023"></a>2023         m.captures
</span><span class="inferred1"><a name="line2024"></a>2024       end
</span><span class="inferred0"><a name="line2025"></a>2025 
</span><span class="marked1"><a name="line2026"></a>2026       def response_class(code)
</span><span class="inferred0"><a name="line2027"></a>2027         CODE_TO_OBJ[code] or
</span><span class="marked1"><a name="line2028"></a>2028         CODE_CLASS_TO_OBJ[code[0,1]] or
</span><span class="inferred0"><a name="line2029"></a>2029         HTTPUnknownResponse
</span><span class="marked1"><a name="line2030"></a>2030       end
</span><span class="inferred0"><a name="line2031"></a>2031 
</span><span class="marked1"><a name="line2032"></a>2032       def each_response_header(sock)
</span><span class="marked0"><a name="line2033"></a>2033         while true
</span><span class="marked1"><a name="line2034"></a>2034           line = sock.readuntil(&quot;\n&quot;, true).sub(/\s+\z/, '')
</span><span class="marked0"><a name="line2035"></a>2035           break if line.empty?
</span><span class="inferred1"><a name="line2036"></a>2036           m = /\A([^:]+):\s*/.match(line) or
</span><span class="marked0"><a name="line2037"></a>2037               raise HTTPBadResponse, 'wrong header line format'
</span><span class="marked1"><a name="line2038"></a>2038           yield m[1], m.post_match
</span><span class="inferred0"><a name="line2039"></a>2039         end
</span><span class="marked1"><a name="line2040"></a>2040       end
</span><span class="inferred0"><a name="line2041"></a>2041     end
</span><span class="inferred1"><a name="line2042"></a>2042 
</span><span class="inferred0"><a name="line2043"></a>2043     # next is to fix bug in RDoc, where the private inside class &lt;&lt; self
</span><span class="inferred1"><a name="line2044"></a>2044     # spills out.
</span><span class="marked0"><a name="line2045"></a>2045     public 
</span><span class="inferred1"><a name="line2046"></a>2046 
</span><span class="marked0"><a name="line2047"></a>2047     include HTTPHeader
</span><span class="inferred1"><a name="line2048"></a>2048 
</span><span class="marked0"><a name="line2049"></a>2049     def initialize(httpv, code, msg)   #:nodoc: internal use only
</span><span class="marked1"><a name="line2050"></a>2050       @http_version = httpv
</span><span class="marked0"><a name="line2051"></a>2051       @code         = code
</span><span class="marked1"><a name="line2052"></a>2052       @message      = msg
</span><span class="marked0"><a name="line2053"></a>2053       initialize_http_header nil
</span><span class="marked1"><a name="line2054"></a>2054       @body = nil
</span><span class="marked0"><a name="line2055"></a>2055       @read = false
</span><span class="inferred1"><a name="line2056"></a>2056     end
</span><span class="inferred0"><a name="line2057"></a>2057 
</span><span class="inferred1"><a name="line2058"></a>2058     # The HTTP version supported by the server.
</span><span class="marked0"><a name="line2059"></a>2059     attr_reader :http_version
</span><span class="inferred1"><a name="line2060"></a>2060 
</span><span class="inferred0"><a name="line2061"></a>2061     # HTTP result code string. For example, '302'.  You can also
</span><span class="inferred1"><a name="line2062"></a>2062     # determine the response type by which response subclass the
</span><span class="inferred0"><a name="line2063"></a>2063     # response object is an instance of.
</span><span class="marked1"><a name="line2064"></a>2064     attr_reader :code
</span><span class="inferred0"><a name="line2065"></a>2065 
</span><span class="inferred1"><a name="line2066"></a>2066     # HTTP result message. For example, 'Not Found'.
</span><span class="marked0"><a name="line2067"></a>2067     attr_reader :message
</span><span class="marked1"><a name="line2068"></a>2068     alias msg message   # :nodoc: obsolete
</span><span class="inferred0"><a name="line2069"></a>2069 
</span><span class="marked1"><a name="line2070"></a>2070     def inspect
</span><span class="uncovered0"><a name="line2071"></a>2071       &quot;#&lt;#{self.class} #{@code} #{@message} readbody=#{@read}&gt;&quot;
</span><span class="uncovered1"><a name="line2072"></a>2072     end
</span><span class="inferred0"><a name="line2073"></a>2073 
</span><span class="inferred1"><a name="line2074"></a>2074     # For backward compatibility.
</span><span class="inferred0"><a name="line2075"></a>2075     # To allow Net::HTTP 1.1 style assignment
</span><span class="inferred1"><a name="line2076"></a>2076     # e.g.
</span><span class="inferred0"><a name="line2077"></a>2077     #    response, body = Net::HTTP.get(....)
</span><span class="inferred1"><a name="line2078"></a>2078     # 
</span><span class="marked0"><a name="line2079"></a>2079     def to_ary
</span><span class="uncovered1"><a name="line2080"></a>2080       warn &quot;net/http.rb: warning: Net::HTTP v1.1 style assignment found at #{caller(1)[0]}; use `response = http.get(...)' instead.&quot; if $VERBOSE
</span><span class="uncovered0"><a name="line2081"></a>2081       res = self.dup
</span><span class="uncovered1"><a name="line2082"></a>2082       class &lt;&lt; res
</span><span class="uncovered0"><a name="line2083"></a>2083         undef to_ary
</span><span class="uncovered1"><a name="line2084"></a>2084       end
</span><span class="uncovered0"><a name="line2085"></a>2085       [res, res.body]
</span><span class="uncovered1"><a name="line2086"></a>2086     end
</span><span class="inferred0"><a name="line2087"></a>2087 
</span><span class="inferred1"><a name="line2088"></a>2088     #
</span><span class="inferred0"><a name="line2089"></a>2089     # response &lt;-&gt; exception relationship
</span><span class="inferred1"><a name="line2090"></a>2090     #
</span><span class="inferred0"><a name="line2091"></a>2091 
</span><span class="marked1"><a name="line2092"></a>2092     def code_type   #:nodoc:
</span><span class="uncovered0"><a name="line2093"></a>2093       self.class
</span><span class="uncovered1"><a name="line2094"></a>2094     end
</span><span class="inferred0"><a name="line2095"></a>2095 
</span><span class="marked1"><a name="line2096"></a>2096     def error!   #:nodoc:
</span><span class="uncovered0"><a name="line2097"></a>2097       raise error_type().new(@code + ' ' + @message.dump, self)
</span><span class="uncovered1"><a name="line2098"></a>2098     end
</span><span class="inferred0"><a name="line2099"></a>2099 
</span><span class="marked1"><a name="line2100"></a>2100     def error_type   #:nodoc:
</span><span class="uncovered0"><a name="line2101"></a>2101       self.class::EXCEPTION_TYPE
</span><span class="uncovered1"><a name="line2102"></a>2102     end
</span><span class="inferred0"><a name="line2103"></a>2103 
</span><span class="inferred1"><a name="line2104"></a>2104     # Raises HTTP error if the response is not 2xx.
</span><span class="marked0"><a name="line2105"></a>2105     def value
</span><span class="uncovered1"><a name="line2106"></a>2106       error! unless self.kind_of?(HTTPSuccess)
</span><span class="uncovered0"><a name="line2107"></a>2107     end
</span><span class="inferred1"><a name="line2108"></a>2108 
</span><span class="inferred0"><a name="line2109"></a>2109     #
</span><span class="inferred1"><a name="line2110"></a>2110     # header (for backward compatibility only; DO NOT USE)
</span><span class="inferred0"><a name="line2111"></a>2111     #
</span><span class="inferred1"><a name="line2112"></a>2112 
</span><span class="marked0"><a name="line2113"></a>2113     def response   #:nodoc:
</span><span class="uncovered1"><a name="line2114"></a>2114       warn &quot;#{caller(1)[0]}: warning: HTTPResponse#response is obsolete&quot; if $VERBOSE
</span><span class="uncovered0"><a name="line2115"></a>2115       self
</span><span class="uncovered1"><a name="line2116"></a>2116     end
</span><span class="inferred0"><a name="line2117"></a>2117 
</span><span class="marked1"><a name="line2118"></a>2118     def header   #:nodoc:
</span><span class="uncovered0"><a name="line2119"></a>2119       warn &quot;#{caller(1)[0]}: warning: HTTPResponse#header is obsolete&quot; if $VERBOSE
</span><span class="uncovered1"><a name="line2120"></a>2120       self
</span><span class="uncovered0"><a name="line2121"></a>2121     end
</span><span class="inferred1"><a name="line2122"></a>2122 
</span><span class="marked0"><a name="line2123"></a>2123     def read_header   #:nodoc:
</span><span class="uncovered1"><a name="line2124"></a>2124       warn &quot;#{caller(1)[0]}: warning: HTTPResponse#read_header is obsolete&quot; if $VERBOSE
</span><span class="uncovered0"><a name="line2125"></a>2125       self
</span><span class="uncovered1"><a name="line2126"></a>2126     end
</span><span class="inferred0"><a name="line2127"></a>2127 
</span><span class="inferred1"><a name="line2128"></a>2128     #
</span><span class="inferred0"><a name="line2129"></a>2129     # body
</span><span class="inferred1"><a name="line2130"></a>2130     #
</span><span class="inferred0"><a name="line2131"></a>2131 
</span><span class="marked1"><a name="line2132"></a>2132     def reading_body(sock, reqmethodallowbody)  #:nodoc: internal use only
</span><span class="marked0"><a name="line2133"></a>2133       @socket = sock
</span><span class="marked1"><a name="line2134"></a>2134       @body_exist = reqmethodallowbody &amp;&amp; self.class.body_permitted?
</span><span class="marked0"><a name="line2135"></a>2135       begin
</span><span class="marked1"><a name="line2136"></a>2136         yield
</span><span class="marked0"><a name="line2137"></a>2137         self.body   # ensure to read body
</span><span class="inferred1"><a name="line2138"></a>2138       ensure
</span><span class="marked0"><a name="line2139"></a>2139         @socket = nil
</span><span class="inferred1"><a name="line2140"></a>2140       end
</span><span class="inferred0"><a name="line2141"></a>2141     end
</span><span class="inferred1"><a name="line2142"></a>2142 
</span><span class="inferred0"><a name="line2143"></a>2143     # Gets entity body.  If the block given, yields it to +block+.
</span><span class="inferred1"><a name="line2144"></a>2144     # The body is provided in fragments, as it is read in from the socket.
</span><span class="inferred0"><a name="line2145"></a>2145     #
</span><span class="inferred1"><a name="line2146"></a>2146     # Calling this method a second or subsequent time will return the
</span><span class="inferred0"><a name="line2147"></a>2147     # already read string.
</span><span class="inferred1"><a name="line2148"></a>2148     #
</span><span class="inferred0"><a name="line2149"></a>2149     #   http.request_get('/index.html') {|res|
</span><span class="inferred1"><a name="line2150"></a>2150     #     puts res.read_body
</span><span class="inferred0"><a name="line2151"></a>2151     #   }
</span><span class="inferred1"><a name="line2152"></a>2152     #
</span><span class="inferred0"><a name="line2153"></a>2153     #   http.request_get('/index.html') {|res|
</span><span class="inferred1"><a name="line2154"></a>2154     #     p res.read_body.object_id   # 538149362
</span><span class="inferred0"><a name="line2155"></a>2155     #     p res.read_body.object_id   # 538149362
</span><span class="inferred1"><a name="line2156"></a>2156     #   }
</span><span class="inferred0"><a name="line2157"></a>2157     #
</span><span class="inferred1"><a name="line2158"></a>2158     #   # using iterator
</span><span class="inferred0"><a name="line2159"></a>2159     #   http.request_get('/index.html') {|res|
</span><span class="inferred1"><a name="line2160"></a>2160     #     res.read_body do |segment|
</span><span class="inferred0"><a name="line2161"></a>2161     #       print segment
</span><span class="inferred1"><a name="line2162"></a>2162     #     end
</span><span class="inferred0"><a name="line2163"></a>2163     #   }
</span><span class="inferred1"><a name="line2164"></a>2164     #
</span><span class="marked0"><a name="line2165"></a>2165     def read_body(dest = nil, &amp;block)
</span><span class="marked1"><a name="line2166"></a>2166       if @read
</span><span class="marked0"><a name="line2167"></a>2167         raise IOError, &quot;#{self.class}\#read_body called twice&quot; if dest or block
</span><span class="marked1"><a name="line2168"></a>2168         return @body
</span><span class="inferred0"><a name="line2169"></a>2169       end
</span><span class="marked1"><a name="line2170"></a>2170       to = procdest(dest, block)
</span><span class="marked0"><a name="line2171"></a>2171       stream_check
</span><span class="marked1"><a name="line2172"></a>2172       if @body_exist
</span><span class="marked0"><a name="line2173"></a>2173         read_body_0 to
</span><span class="marked1"><a name="line2174"></a>2174         @body = to
</span><span class="uncovered0"><a name="line2175"></a>2175       else
</span><span class="uncovered1"><a name="line2176"></a>2176         @body = nil
</span><span class="uncovered0"><a name="line2177"></a>2177       end
</span><span class="marked1"><a name="line2178"></a>2178       @read = true
</span><span class="inferred0"><a name="line2179"></a>2179 
</span><span class="marked1"><a name="line2180"></a>2180       @body
</span><span class="inferred0"><a name="line2181"></a>2181     end
</span><span class="inferred1"><a name="line2182"></a>2182 
</span><span class="inferred0"><a name="line2183"></a>2183     # Returns the entity body.
</span><span class="inferred1"><a name="line2184"></a>2184     #
</span><span class="inferred0"><a name="line2185"></a>2185     # Calling this method a second or subsequent time will return the
</span><span class="inferred1"><a name="line2186"></a>2186     # already read string.
</span><span class="inferred0"><a name="line2187"></a>2187     #
</span><span class="inferred1"><a name="line2188"></a>2188     #   http.request_get('/index.html') {|res|
</span><span class="inferred0"><a name="line2189"></a>2189     #     puts res.body
</span><span class="inferred1"><a name="line2190"></a>2190     #   }
</span><span class="inferred0"><a name="line2191"></a>2191     #
</span><span class="inferred1"><a name="line2192"></a>2192     #   http.request_get('/index.html') {|res|
</span><span class="inferred0"><a name="line2193"></a>2193     #     p res.body.object_id   # 538149362
</span><span class="inferred1"><a name="line2194"></a>2194     #     p res.body.object_id   # 538149362
</span><span class="inferred0"><a name="line2195"></a>2195     #   }
</span><span class="inferred1"><a name="line2196"></a>2196     #
</span><span class="marked0"><a name="line2197"></a>2197     def body
</span><span class="marked1"><a name="line2198"></a>2198       read_body()
</span><span class="marked0"><a name="line2199"></a>2199     end
</span><span class="inferred1"><a name="line2200"></a>2200 
</span><span class="marked0"><a name="line2201"></a>2201     alias entity body   #:nodoc: obsolete
</span><span class="inferred1"><a name="line2202"></a>2202 
</span><span class="marked0"><a name="line2203"></a>2203     private
</span><span class="inferred1"><a name="line2204"></a>2204 
</span><span class="marked0"><a name="line2205"></a>2205     def read_body_0(dest)
</span><span class="marked1"><a name="line2206"></a>2206       if chunked?
</span><span class="uncovered0"><a name="line2207"></a>2207         read_chunked dest
</span><span class="uncovered1"><a name="line2208"></a>2208         return
</span><span class="uncovered0"><a name="line2209"></a>2209       end
</span><span class="marked1"><a name="line2210"></a>2210       clen = content_length()
</span><span class="marked0"><a name="line2211"></a>2211       if clen
</span><span class="marked1"><a name="line2212"></a>2212         @socket.read clen, dest, true   # ignore EOF
</span><span class="marked0"><a name="line2213"></a>2213         return
</span><span class="inferred1"><a name="line2214"></a>2214       end
</span><span class="uncovered0"><a name="line2215"></a>2215       clen = range_length()
</span><span class="uncovered1"><a name="line2216"></a>2216       if clen
</span><span class="uncovered0"><a name="line2217"></a>2217         @socket.read clen, dest
</span><span class="uncovered1"><a name="line2218"></a>2218         return
</span><span class="uncovered0"><a name="line2219"></a>2219       end
</span><span class="uncovered1"><a name="line2220"></a>2220       @socket.read_all dest
</span><span class="uncovered0"><a name="line2221"></a>2221     end
</span><span class="inferred1"><a name="line2222"></a>2222 
</span><span class="marked0"><a name="line2223"></a>2223     def read_chunked(dest)
</span><span class="uncovered1"><a name="line2224"></a>2224       len = nil
</span><span class="uncovered0"><a name="line2225"></a>2225       total = 0
</span><span class="uncovered1"><a name="line2226"></a>2226       while true
</span><span class="uncovered0"><a name="line2227"></a>2227         line = @socket.readline
</span><span class="uncovered1"><a name="line2228"></a>2228         hexlen = line.slice(/[0-9a-fA-F]+/) or
</span><span class="uncovered0"><a name="line2229"></a>2229             raise HTTPBadResponse, &quot;wrong chunk size line: #{line}&quot;
</span><span class="uncovered1"><a name="line2230"></a>2230         len = hexlen.hex
</span><span class="uncovered0"><a name="line2231"></a>2231         break if len == 0
</span><span class="uncovered1"><a name="line2232"></a>2232         @socket.read len, dest; total += len
</span><span class="uncovered0"><a name="line2233"></a>2233         @socket.read 2   # \r\n
</span><span class="uncovered1"><a name="line2234"></a>2234       end
</span><span class="uncovered0"><a name="line2235"></a>2235       until @socket.readline.empty?
</span><span class="uncovered1"><a name="line2236"></a>2236         # none
</span><span class="uncovered0"><a name="line2237"></a>2237       end
</span><span class="uncovered1"><a name="line2238"></a>2238     end
</span><span class="inferred0"><a name="line2239"></a>2239 
</span><span class="marked1"><a name="line2240"></a>2240     def stream_check
</span><span class="marked0"><a name="line2241"></a>2241       raise IOError, 'attempt to read body out of block' if @socket.closed?
</span><span class="marked1"><a name="line2242"></a>2242     end
</span><span class="inferred0"><a name="line2243"></a>2243 
</span><span class="marked1"><a name="line2244"></a>2244     def procdest(dest, block)
</span><span class="inferred0"><a name="line2245"></a>2245       raise ArgumentError, 'both arg and block given for HTTP method' \
</span><span class="marked1"><a name="line2246"></a>2246           if dest and block
</span><span class="marked0"><a name="line2247"></a>2247       if block
</span><span class="uncovered1"><a name="line2248"></a>2248         ReadAdapter.new(block)
</span><span class="inferred0"><a name="line2249"></a>2249       else
</span><span class="marked1"><a name="line2250"></a>2250         dest || ''
</span><span class="inferred0"><a name="line2251"></a>2251       end
</span><span class="inferred1"><a name="line2252"></a>2252     end
</span><span class="inferred0"><a name="line2253"></a>2253 
</span><span class="inferred1"><a name="line2254"></a>2254   end
</span><span class="inferred0"><a name="line2255"></a>2255 
</span><span class="inferred1"><a name="line2256"></a>2256 
</span><span class="inferred0"><a name="line2257"></a>2257   # :enddoc:
</span><span class="inferred1"><a name="line2258"></a>2258 
</span><span class="inferred0"><a name="line2259"></a>2259   #--
</span><span class="inferred1"><a name="line2260"></a>2260   # for backward compatibility
</span><span class="marked0"><a name="line2261"></a>2261   class HTTP
</span><span class="marked1"><a name="line2262"></a>2262     ProxyMod = ProxyDelta
</span><span class="inferred0"><a name="line2263"></a>2263   end
</span><span class="marked1"><a name="line2264"></a>2264   module NetPrivate
</span><span class="marked0"><a name="line2265"></a>2265     HTTPRequest = ::Net::HTTPRequest
</span><span class="inferred1"><a name="line2266"></a>2266   end
</span><span class="inferred0"><a name="line2267"></a>2267 
</span><span class="marked1"><a name="line2268"></a>2268   HTTPInformationCode = HTTPInformation
</span><span class="marked0"><a name="line2269"></a>2269   HTTPSuccessCode     = HTTPSuccess
</span><span class="marked1"><a name="line2270"></a>2270   HTTPRedirectionCode = HTTPRedirection
</span><span class="marked0"><a name="line2271"></a>2271   HTTPRetriableCode   = HTTPRedirection
</span><span class="marked1"><a name="line2272"></a>2272   HTTPClientErrorCode = HTTPClientError
</span><span class="marked0"><a name="line2273"></a>2273   HTTPFatalErrorCode  = HTTPClientError
</span><span class="marked1"><a name="line2274"></a>2274   HTTPServerErrorCode = HTTPServerError
</span><span class="marked0"><a name="line2275"></a>2275   HTTPResponceReceiver = HTTPResponse
</span><span class="inferred1"><a name="line2276"></a>2276 
</span><span class="inferred0"><a name="line2277"></a>2277 end   # module Net
</span></pre><hr/>
    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a>
   version 0.8.1.2.</p>
<p><a href='http://validator.w3.org/check/referer'><img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88'/>
        </a>
      <a href='http://jigsaw.w3.org/css-validator/check/referer'><img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px'/>
        </a>
      </p>
    </body>
  </html>
